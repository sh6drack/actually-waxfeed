From b0ae6795e07e6badeacbac8b87c8a82310834584 Mon Sep 17 00:00:00 2001
From: Shadrack Annor <shadrack@mac.mynetworksettings.com>
Date: Sat, 24 Jan 2026 10:22:13 -0500
Subject: [PATCH 03/50] Add TasteID Music Networks, Listening Mode, and Pattern
 components with theme support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- Created MusicNetworks.tsx: 7 Music Networks visualization based on Yeo model
  - Radar/spider chart showing network activations
  - Network legend with Yeo cognitive model mapping
  - Detection signals for Discovery and Deep Dive modes

- Created ListeningModeIndicator.tsx: Shows dominant listening mode
  - Displays current mode with icon and activation percentage
  - Provides personalized suggestions based on mode

- Created PatternBadges.tsx: Pattern detection and display
  - Signature patterns (Discovery‚ÜîComfort, Deep Dive, etc.)
  - Rating patterns (Critical Ear, Music Optimist, etc.)
  - Engagement patterns (Contrarian, Hidden Gem Hunter, etc.)

- Created PolarityScore.tsx: Polarity Score 2.0 component
  - Identity strength metric with formula breakdown
  - Score interpretation levels

- Created TasteConsolidation.tsx: Taste consolidation tracking
  - Shows strengthening vs fading tastes over time
  - Tracks genre and artist consolidation trends

- Updated index.ts: Exported all new TasteID components

- Fixed CSS variable usage across all components:
  - Replaced text-[--muted] with text-muted-foreground
  - Replaced border-[--border] with border-border
  - Replaced bg-[--surface] with bg-muted/10
  - Ensured proper theme support for light/dark modes

- Added comprehensive E2E tests (e2e/tasteid-components.spec.ts):
  - Tests for all 7 Music Networks display
  - Listening Mode Indicator functionality
  - Pattern Detection display
  - Theme color application (light/dark modes)
  - Responsive design across viewports
  - Accessibility checks
  - Integration tests

All components use correct TasteID terminology (not BrainID) and proper
Tailwind CSS classes with CSS variables for full theme support.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
---
 e2e/tasteid-components.spec.ts                | 285 ++++++++++++++
 .../tasteid/ListeningModeIndicator.tsx        | 103 +++++
 src/components/tasteid/MusicNetworks.tsx      | 354 ++++++++++++++++++
 src/components/tasteid/PatternBadges.tsx      | 243 ++++++++++++
 src/components/tasteid/PolarityScore.tsx      | 220 +++++++++++
 src/components/tasteid/TasteConsolidation.tsx | 169 +++++++++
 src/components/tasteid/index.ts               |  37 ++
 7 files changed, 1411 insertions(+)
 create mode 100644 e2e/tasteid-components.spec.ts
 create mode 100644 src/components/tasteid/ListeningModeIndicator.tsx
 create mode 100644 src/components/tasteid/MusicNetworks.tsx
 create mode 100644 src/components/tasteid/PatternBadges.tsx
 create mode 100644 src/components/tasteid/PolarityScore.tsx
 create mode 100644 src/components/tasteid/TasteConsolidation.tsx

diff --git a/e2e/tasteid-components.spec.ts b/e2e/tasteid-components.spec.ts
new file mode 100644
index 0000000..c43f7e5
--- /dev/null
+++ b/e2e/tasteid-components.spec.ts
@@ -0,0 +1,285 @@
+import { test, expect } from '@playwright/test'
+
+test.describe('TasteID Components', () => {
+  test.beforeEach(async ({ page }) => {
+    // Navigate to a user's TasteID page
+    // Using a test user or creating one during test setup
+    await page.goto('/u/testuser/tasteid')
+  })
+
+  test.describe('Music Networks Visualization', () => {
+    test('should display 7 Music Networks visualization', async ({ page }) => {
+      // Check for the section header
+      await expect(page.getByText('7 MUSIC NETWORKS')).toBeVisible()
+
+      // Check for the Yeo Model badge
+      await expect(page.getByText('YEO MODEL')).toBeVisible()
+
+      // Verify the description text
+      await expect(page.getByText(/7 distinct modes of musical engagement/i)).toBeVisible()
+    })
+
+    test('should display all 7 network labels', async ({ page }) => {
+      const networks = [
+        'Discovery',
+        'Comfort',
+        'Deep Dive',
+        'Reactive',
+        'Emotional',
+        'Social',
+        'Aesthetic'
+      ]
+
+      for (const network of networks) {
+        await expect(page.getByText(network, { exact: false })).toBeVisible()
+      }
+    })
+
+    test('should display network detection signals', async ({ page }) => {
+      await expect(page.getByText('Network Detection Signals')).toBeVisible()
+      await expect(page.getByText('DISCOVERY MODE')).toBeVisible()
+      await expect(page.getByText('DEEP DIVE MODE')).toBeVisible()
+    })
+
+    test('should use correct TasteID terminology (not BrainID)', async ({ page }) => {
+      // Ensure no BrainID references exist
+      const brainIdText = await page.getByText(/brainid/i).count()
+      expect(brainIdText).toBe(0)
+
+      // Verify TasteID terminology is used
+      await expect(page.getByText(/tasteid/i).first()).toBeVisible()
+    })
+  })
+
+  test.describe('Listening Mode Indicator', () => {
+    test('should display current listening mode', async ({ page }) => {
+      await expect(page.getByText('Current Listening Mode')).toBeVisible()
+    })
+
+    test('should show mode activation percentage', async ({ page }) => {
+      // Look for percentage text pattern
+      const activationText = page.locator('text=/\\d+% activation/')
+      await expect(activationText).toBeVisible()
+    })
+
+    test('should display mode suggestion', async ({ page }) => {
+      await expect(page.getByText('Suggestion')).toBeVisible()
+    })
+
+    test('should highlight dominant mode with icon and color', async ({ page }) => {
+      // Verify an emoji icon is present (any of the network icons)
+      const icons = ['üîç', 'üè†', 'üíø', '‚ö°', 'üíú', 'ü§ù', 'üé®']
+      let foundIcon = false
+
+      for (const icon of icons) {
+        const iconCount = await page.getByText(icon).count()
+        if (iconCount > 0) {
+          foundIcon = true
+          break
+        }
+      }
+
+      expect(foundIcon).toBe(true)
+    })
+  })
+
+  test.describe('Pattern Detection', () => {
+    test('should display pattern section when patterns exist', async ({ page }) => {
+      const patternsSection = page.getByText('YOUR PATTERNS')
+      const patternsCount = await patternsSection.count()
+
+      if (patternsCount > 0) {
+        await expect(patternsSection).toBeVisible()
+      }
+    })
+
+    test('should display pattern descriptions', async ({ page }) => {
+      // Check for common patterns
+      const patterns = [
+        'Discovery‚ÜîComfort Oscillation',
+        'Deep Dive Sprints',
+        'New Release Hunter',
+        'Emotional Listener',
+        'Critical Ear',
+        'Music Optimist'
+      ]
+
+      // At least one pattern should be visible if the section exists
+      const patternsSection = await page.getByText('YOUR PATTERNS').count()
+      if (patternsSection > 0) {
+        let foundPattern = false
+        for (const pattern of patterns) {
+          const count = await page.getByText(pattern).count()
+          if (count > 0) {
+            foundPattern = true
+            break
+          }
+        }
+        expect(foundPattern).toBe(true)
+      }
+    })
+  })
+
+  test.describe('Listening Signature', () => {
+    test('should display Listening Signature section', async ({ page }) => {
+      await expect(page.getByText('LISTENING SIGNATURE')).toBeVisible()
+      await expect(page.getByText('POLARITY 1.2')).toBeVisible()
+    })
+
+    test('should show uniqueness metrics', async ({ page }) => {
+      // Check for uniqueness indicator
+      const uniquenessSection = page.getByText('WHAT MAKES YOU UNIQUE')
+      const count = await uniquenessSection.count()
+
+      if (count > 0) {
+        await expect(uniquenessSection).toBeVisible()
+      }
+    })
+
+    test('should display network percentages', async ({ page }) => {
+      // Look for percentage values in the signature
+      const percentagePattern = /\d+%/
+      const percentages = page.locator(`text=${percentagePattern}`)
+      await expect(percentages.first()).toBeVisible()
+    })
+  })
+
+  test.describe('Theme Support', () => {
+    test('should apply theme colors correctly in light mode', async ({ page, context }) => {
+      // Set theme to light
+      await page.evaluate(() => {
+        document.documentElement.classList.remove('dark')
+        document.documentElement.classList.add('light')
+      })
+
+      // Wait for theme to apply
+      await page.waitForTimeout(300)
+
+      // Check that elements are visible and styled
+      const section = page.locator('text=7 MUSIC NETWORKS').locator('..')
+      await expect(section).toBeVisible()
+
+      // Verify border colors are applied (using CSS variable)
+      const borderElement = page.locator('.border-border').first()
+      if (await borderElement.count() > 0) {
+        await expect(borderElement).toBeVisible()
+      }
+    })
+
+    test('should apply theme colors correctly in dark mode', async ({ page }) => {
+      // Set theme to dark
+      await page.evaluate(() => {
+        document.documentElement.classList.remove('light')
+        document.documentElement.classList.add('dark')
+      })
+
+      // Wait for theme to apply
+      await page.waitForTimeout(300)
+
+      // Check that elements are visible and styled
+      const section = page.locator('text=7 MUSIC NETWORKS').locator('..')
+      await expect(section).toBeVisible()
+
+      // Verify muted text colors are applied
+      const mutedText = page.locator('.text-muted-foreground').first()
+      if (await mutedText.count() > 0) {
+        await expect(mutedText).toBeVisible()
+      }
+    })
+
+    test('should use CSS variables for all color values', async ({ page }) => {
+      // Check that no hardcoded colors are used (except for specific network colors)
+      const html = await page.content()
+
+      // Should not have [--muted] or [--border] syntax (old incorrect usage)
+      expect(html).not.toContain('text-[--muted]')
+      expect(html).not.toContain('border-[--border]')
+      expect(html).not.toContain('bg-[--surface]')
+    })
+  })
+
+  test.describe('Responsive Design', () => {
+    test('should display correctly on mobile viewport', async ({ page }) => {
+      await page.setViewportSize({ width: 375, height: 667 })
+
+      // Check that key sections are visible
+      await expect(page.getByText('7 MUSIC NETWORKS')).toBeVisible()
+      await expect(page.getByText('LISTENING SIGNATURE')).toBeVisible()
+    })
+
+    test('should display correctly on tablet viewport', async ({ page }) => {
+      await page.setViewportSize({ width: 768, height: 1024 })
+
+      await expect(page.getByText('7 MUSIC NETWORKS')).toBeVisible()
+      await expect(page.getByText('LISTENING SIGNATURE')).toBeVisible()
+    })
+
+    test('should display correctly on desktop viewport', async ({ page }) => {
+      await page.setViewportSize({ width: 1920, height: 1080 })
+
+      await expect(page.getByText('7 MUSIC NETWORKS')).toBeVisible()
+      await expect(page.getByText('LISTENING SIGNATURE')).toBeVisible()
+    })
+  })
+
+  test.describe('Accessibility', () => {
+    test('should have proper heading hierarchy', async ({ page }) => {
+      // Check that h1, h2 elements exist and are in proper order
+      const h1 = await page.locator('h1').count()
+      const h2 = await page.locator('h2').count()
+
+      // At least one h2 should exist for section headings
+      expect(h2).toBeGreaterThan(0)
+    })
+
+    test('should have readable text contrast', async ({ page }) => {
+      // Visual regression would be better, but check visibility
+      const sections = [
+        '7 MUSIC NETWORKS',
+        'LISTENING SIGNATURE',
+        'Current Listening Mode'
+      ]
+
+      for (const section of sections) {
+        const element = page.getByText(section)
+        const count = await element.count()
+        if (count > 0) {
+          await expect(element.first()).toBeVisible()
+        }
+      }
+    })
+  })
+
+  test.describe('Integration Tests', () => {
+    test('should show all major TasteID sections together', async ({ page }) => {
+      // Verify all major sections are present
+      const sections = [
+        'LISTENING SIGNATURE',
+        '7 MUSIC NETWORKS',
+      ]
+
+      for (const section of sections) {
+        await expect(page.getByText(section)).toBeVisible()
+      }
+    })
+
+    test('should display Music Networks Legend with Yeo mapping', async ({ page }) => {
+      // Check for legend section
+      const legendText = page.getByText('7 Music Networks')
+      const count = await legendText.count()
+
+      if (count > 0) {
+        await expect(legendText).toBeVisible()
+      }
+    })
+
+    test('should navigate back to profile from TasteID page', async ({ page }) => {
+      const backLink = page.getByText('Back to profile')
+      await expect(backLink).toBeVisible()
+
+      // Click and verify navigation
+      await backLink.click()
+      await page.waitForURL(/\/u\/testuser$/)
+    })
+  })
+})
diff --git a/src/components/tasteid/ListeningModeIndicator.tsx b/src/components/tasteid/ListeningModeIndicator.tsx
new file mode 100644
index 0000000..d2c41f0
--- /dev/null
+++ b/src/components/tasteid/ListeningModeIndicator.tsx
@@ -0,0 +1,103 @@
+"use client"
+
+import { useMemo } from "react"
+import { MUSIC_NETWORKS, MusicNetworkKey } from "./MusicNetworks"
+
+interface ListeningModeIndicatorProps {
+  networkActivations: Partial<Record<MusicNetworkKey, number>>
+  className?: string
+}
+
+// Determine dominant listening mode from network activations
+function getDominantMode(activations: Partial<Record<MusicNetworkKey, number>>): {
+  mode: MusicNetworkKey
+  value: number
+  label: string
+  suggestion: string
+  icon: string
+  color: string
+} {
+  let maxMode: MusicNetworkKey = "COMFORT"
+  let maxValue = 0
+
+  Object.entries(activations).forEach(([key, value]) => {
+    if (value !== undefined && value > maxValue) {
+      maxValue = value
+      maxMode = key as MusicNetworkKey
+    }
+  })
+
+  const network = MUSIC_NETWORKS[maxMode]
+
+  // Mode-specific suggestions based on the architecture doc
+  const suggestions: Record<MusicNetworkKey, string> = {
+    DISCOVERY: "Try something outside your usual genres",
+    COMFORT: "Revisit an album you haven't played in a while",
+    DEEP_DIVE: "Explore another album from an artist you love",
+    REACTIVE: "Check out this week's new releases",
+    EMOTIONAL: "Find something that matches your current mood",
+    SOCIAL: "See what your friends are listening to",
+    AESTHETIC: "Discover albums with iconic cover art",
+  }
+
+  return {
+    mode: maxMode,
+    value: maxValue,
+    label: network.name,
+    suggestion: suggestions[maxMode],
+    icon: network.icon,
+    color: network.color,
+  }
+}
+
+export function ListeningModeIndicator({
+  networkActivations,
+  className = "",
+}: ListeningModeIndicatorProps) {
+  const dominant = useMemo(() => getDominantMode(networkActivations), [networkActivations])
+
+  return (
+    <div className={`border border-border p-4 ${className}`}>
+      <div className="flex items-center gap-2 mb-3">
+        <span className="text-[10px] tracking-[0.2em] uppercase text-muted-foreground">
+          Current Listening Mode
+        </span>
+      </div>
+
+      <div className="flex items-center gap-3">
+        <span className="text-2xl">{dominant.icon}</span>
+        <div>
+          <p className="text-lg font-bold" style={{ color: dominant.color }}>
+            {dominant.label}
+          </p>
+          <p className="text-xs text-muted-foreground">
+            {Math.round(dominant.value * 100)}% activation
+          </p>
+        </div>
+      </div>
+
+      <div className="mt-4 pt-3 border-t border-border">
+        <p className="text-xs text-muted-foreground/70 mb-1">Suggestion</p>
+        <p className="text-sm text-foreground">{dominant.suggestion}</p>
+      </div>
+    </div>
+  )
+}
+
+// Compact badge version
+export function ListeningModeBadge({
+  networkActivations,
+  className = "",
+}: ListeningModeIndicatorProps) {
+  const dominant = useMemo(() => getDominantMode(networkActivations), [networkActivations])
+
+  return (
+    <span
+      className={`inline-flex items-center gap-1.5 px-2 py-1 text-xs border ${className}`}
+      style={{ borderColor: dominant.color, color: dominant.color }}
+    >
+      <span>{dominant.icon}</span>
+      <span className="font-medium">{dominant.label}</span>
+    </span>
+  )
+}
diff --git a/src/components/tasteid/MusicNetworks.tsx b/src/components/tasteid/MusicNetworks.tsx
new file mode 100644
index 0000000..1bb923a
--- /dev/null
+++ b/src/components/tasteid/MusicNetworks.tsx
@@ -0,0 +1,354 @@
+"use client"
+
+import { useMemo } from "react"
+
+// TasteID 7 Music Networks - adapted from Yeo 7-Network cognitive model
+// Maps listening behavior to 7 distinct modes of musical engagement
+export const MUSIC_NETWORKS = {
+  DISCOVERY: {
+    name: "Discovery",
+    abbrev: "FP",
+    yeoNetwork: "Frontoparietal",
+    color: "#60a5fa", // blue
+    icon: "üîç",
+    description: "New artist exploration, genre breadth",
+    typicalRange: "15-30%",
+    signals: ["First-time artist reviews", "Genre diversity", "Low artist repeat rate"]
+  },
+  COMFORT: {
+    name: "Comfort",
+    abbrev: "DMN",
+    yeoNetwork: "Default Mode",
+    color: "#a78bfa", // violet
+    icon: "üè†",
+    description: "Returning to known favorites",
+    typicalRange: "18-32%",
+    signals: ["Re-listens to favorites", "Artist loyalty", "Genre consistency"]
+  },
+  DEEP_DIVE: {
+    name: "Deep Dive",
+    abbrev: "DA",
+    yeoNetwork: "Dorsal Attention",
+    color: "#34d399", // emerald
+    icon: "üíø",
+    description: "Artist catalog exploration depth",
+    typicalRange: "8-20%",
+    signals: ["Multiple albums from same artist", "Chronological exploration", "Discography patterns"]
+  },
+  REACTIVE: {
+    name: "Reactive",
+    abbrev: "VA",
+    yeoNetwork: "Ventral Attention",
+    color: "#fbbf24", // amber
+    icon: "‚ö°",
+    description: "Response to new releases, trends",
+    typicalRange: "10-22%",
+    signals: ["New release reviews", "Trending album activity", "Current chart engagement"]
+  },
+  EMOTIONAL: {
+    name: "Emotional",
+    abbrev: "LIM",
+    yeoNetwork: "Limbic",
+    color: "#f87171", // red
+    icon: "üíú",
+    description: "Rating variance, strong reactions",
+    typicalRange: "8-20%",
+    signals: ["Rating variance", "Strong written reactions", "Polarized scores"]
+  },
+  SOCIAL: {
+    name: "Social",
+    abbrev: "SMN",
+    yeoNetwork: "Somatomotor",
+    color: "#fb923c", // orange
+    icon: "ü§ù",
+    description: "Community engagement, sharing",
+    typicalRange: "3-12%",
+    signals: ["List collaborations", "Comment activity", "Friend interactions"]
+  },
+  AESTHETIC: {
+    name: "Aesthetic",
+    abbrev: "VIS",
+    yeoNetwork: "Visual",
+    color: "#818cf8", // indigo
+    icon: "üé®",
+    description: "Visual/presentation attention",
+    typicalRange: "2-10%",
+    signals: ["Album art attention", "Visual curation", "Presentation focus"]
+  },
+} as const
+
+export type MusicNetworkKey = keyof typeof MUSIC_NETWORKS
+
+interface MusicNetworksVisualizationProps {
+  networkActivations: Partial<Record<MusicNetworkKey, number>> // 0-1 values
+  size?: number
+  className?: string
+  showLabels?: boolean
+  interactive?: boolean
+}
+
+export function MusicNetworksVisualization({
+  networkActivations,
+  size = 280,
+  className = "",
+  showLabels = true,
+  interactive = true,
+}: MusicNetworksVisualizationProps) {
+  // Map to array with all network data
+  const networks = useMemo(() => {
+    const keys = Object.keys(MUSIC_NETWORKS) as MusicNetworkKey[]
+    return keys.map(key => ({
+      key,
+      ...MUSIC_NETWORKS[key],
+      value: networkActivations[key] ?? 0,
+    }))
+  }, [networkActivations])
+
+  const numPoints = networks.length
+  const center = size / 2
+  const maxRadius = (size / 2) * 0.65 // Leave room for labels
+
+  // Calculate points for each network
+  const angleStep = (2 * Math.PI) / numPoints
+  const networkPoints = networks.map((network, i) => {
+    const angle = angleStep * i - Math.PI / 2 // Start from top
+    const radius = network.value * maxRadius
+
+    return {
+      ...network,
+      x: center + radius * Math.cos(angle),
+      y: center + radius * Math.sin(angle),
+      labelX: center + (maxRadius + 28) * Math.cos(angle),
+      labelY: center + (maxRadius + 28) * Math.sin(angle),
+      axisX: center + maxRadius * Math.cos(angle),
+      axisY: center + maxRadius * Math.sin(angle),
+      angle,
+    }
+  })
+
+  // Create filled polygon path for the activation shape
+  const polygonPath = networkPoints.map((p, i) =>
+    `${i === 0 ? "M" : "L"} ${p.x} ${p.y}`
+  ).join(" ") + " Z"
+
+  // Concentric rings for scale
+  const rings = [0.25, 0.5, 0.75, 1].map((scale) => {
+    const ringPoints = Array.from({ length: numPoints }, (_, i) => {
+      const angle = angleStep * i - Math.PI / 2
+      const radius = scale * maxRadius
+      return `${center + radius * Math.cos(angle)},${center + radius * Math.sin(angle)}`
+    })
+    return ringPoints.join(" ")
+  })
+
+  return (
+    <div className={`relative ${className}`} style={{ width: size, height: size }}>
+      <svg width={size} height={size} className="font-mono">
+        <defs>
+          {/* Gradient for the listening signature shape */}
+          <linearGradient id="signatureGradient" x1="0%" y1="0%" x2="100%" y2="100%">
+            <stop offset="0%" stopColor="#60a5fa" stopOpacity="0.3" />
+            <stop offset="50%" stopColor="#a78bfa" stopOpacity="0.2" />
+            <stop offset="100%" stopColor="#34d399" stopOpacity="0.3" />
+          </linearGradient>
+
+          {/* Glow effect */}
+          <filter id="signatureGlow" x="-50%" y="-50%" width="200%" height="200%">
+            <feGaussianBlur stdDeviation="2" result="coloredBlur" />
+            <feMerge>
+              <feMergeNode in="coloredBlur" />
+              <feMergeNode in="SourceGraphic" />
+            </feMerge>
+          </filter>
+        </defs>
+
+        {/* Background rings */}
+        {rings.map((points, i) => (
+          <polygon
+            key={i}
+            points={points}
+            fill="none"
+            stroke="var(--border)"
+            strokeWidth="1"
+            strokeOpacity={i === 3 ? 0.6 : 0.3}
+            strokeDasharray={i < 3 ? "3,3" : "none"}
+          />
+        ))}
+
+        {/* Axis lines */}
+        {networkPoints.map((p, i) => (
+          <line
+            key={i}
+            x1={center}
+            y1={center}
+            x2={p.axisX}
+            y2={p.axisY}
+            stroke="var(--border)"
+            strokeWidth="1"
+            strokeOpacity="0.4"
+          />
+        ))}
+
+        {/* Main activation polygon with gradient */}
+        <path
+          d={polygonPath}
+          fill="url(#signatureGradient)"
+          stroke="var(--accent)"
+          strokeWidth="2"
+          strokeOpacity="0.5"
+          filter="url(#signatureGlow)"
+        />
+
+        {/* Individual network dots with their specific colors */}
+        {networkPoints.map((p, i) => (
+          <g key={i}>
+            {/* Outer glow */}
+            <circle
+              cx={p.x}
+              cy={p.y}
+              r="8"
+              fill={p.color}
+              fillOpacity="0.3"
+            />
+            {/* Main dot */}
+            <circle
+              cx={p.x}
+              cy={p.y}
+              r="5"
+              fill={p.color}
+              stroke="var(--background)"
+              strokeWidth="2"
+              className={interactive ? "transition-all duration-300 cursor-pointer hover:r-6" : ""}
+            />
+          </g>
+        ))}
+
+        {/* Labels */}
+        {showLabels && networkPoints.map((p, i) => {
+          // Determine text anchor based on position
+          let textAnchor: "start" | "middle" | "end" = "middle"
+          if (p.labelX < center - 15) textAnchor = "end"
+          if (p.labelX > center + 15) textAnchor = "start"
+
+          return (
+            <g key={i}>
+              <text
+                x={p.labelX}
+                y={p.labelY}
+                textAnchor={textAnchor}
+                dominantBaseline="middle"
+                className="text-[9px] uppercase tracking-wider"
+                fill={p.color}
+                fontWeight="bold"
+              >
+                {p.name}
+              </text>
+              {/* Show percentage */}
+              <text
+                x={p.labelX}
+                y={p.labelY + 12}
+                textAnchor={textAnchor}
+                dominantBaseline="middle"
+                className="text-[8px]"
+                fill="var(--muted)"
+              >
+                {Math.round(p.value * 100)}%
+              </text>
+            </g>
+          )
+        })}
+
+        {/* Center label */}
+        <text
+          x={center}
+          y={center - 8}
+          textAnchor="middle"
+          dominantBaseline="middle"
+          className="text-[8px] uppercase tracking-widest"
+          fill="var(--muted)"
+        >
+          LISTENING
+        </text>
+        <text
+          x={center}
+          y={center + 6}
+          textAnchor="middle"
+          dominantBaseline="middle"
+          className="text-[10px] uppercase tracking-wider font-bold"
+          fill="var(--foreground)"
+        >
+          SIGNATURE
+        </text>
+      </svg>
+    </div>
+  )
+}
+
+// Compact version for inline display
+export function MusicNetworksMini({
+  networkActivations,
+  size = 80,
+  className = "",
+}: {
+  networkActivations: Partial<Record<MusicNetworkKey, number>>
+  size?: number
+  className?: string
+}) {
+  return (
+    <MusicNetworksVisualization
+      networkActivations={networkActivations}
+      size={size}
+      showLabels={false}
+      interactive={false}
+      className={className}
+    />
+  )
+}
+
+// Network legend component
+export function MusicNetworksLegend({
+  showYeoMapping = false
+}: {
+  showYeoMapping?: boolean
+}) {
+  const networks = Object.entries(MUSIC_NETWORKS) as [MusicNetworkKey, typeof MUSIC_NETWORKS[MusicNetworkKey]][]
+
+  return (
+    <div className="space-y-2">
+      <p className="text-[10px] tracking-[0.2em] uppercase text-muted-foreground mb-3">
+        7 Music Networks
+      </p>
+      <div className="grid grid-cols-2 gap-x-4 gap-y-2">
+        {networks.map(([key, network]) => (
+          <div key={key} className="flex items-start gap-2">
+            <div
+              className="w-3 h-3 flex-shrink-0 mt-0.5"
+              style={{ backgroundColor: network.color }}
+            />
+            <div className="min-w-0">
+              <p className="text-xs font-bold truncate">
+                {network.icon} {network.name}
+              </p>
+              <p className="text-[10px] text-muted-foreground truncate">{network.typicalRange}</p>
+              {showYeoMapping && (
+                <p className="text-[9px] text-muted-foreground/70 mt-0.5">
+                  {network.abbrev} ‚Üí {network.yeoNetwork}
+                </p>
+              )}
+            </div>
+          </div>
+        ))}
+      </div>
+    </div>
+  )
+}
+
+// Loading skeleton
+export function MusicNetworksSkeleton({ size = 280 }: { size?: number }) {
+  return (
+    <div
+      className="bg-muted/20 animate-pulse"
+      style={{ width: size, height: size, borderRadius: '50%' }}
+    />
+  )
+}
diff --git a/src/components/tasteid/PatternBadges.tsx b/src/components/tasteid/PatternBadges.tsx
new file mode 100644
index 0000000..fe37cfe
--- /dev/null
+++ b/src/components/tasteid/PatternBadges.tsx
@@ -0,0 +1,243 @@
+"use client"
+
+// TasteID Pattern Detection - from the architecture doc
+// These patterns unlock as users review more albums
+
+export const TASTEID_PATTERNS = {
+  // Signature-Based Patterns
+  DISCOVERY_COMFORT_OSCILLATION: {
+    id: "discovery_comfort_oscillation",
+    name: "Discovery‚ÜîComfort Oscillation",
+    description: "Healthy balance between exploring new music and returning to favorites",
+    category: "signature",
+    minReviews: 10,
+  },
+  DEEP_DIVE_SPRINTS: {
+    id: "deep_dive_sprints",
+    name: "Deep Dive Sprints",
+    description: "Goes all-in on artists when something clicks",
+    category: "signature",
+    minReviews: 10,
+  },
+  NEW_RELEASE_HUNTER: {
+    id: "new_release_hunter",
+    name: "New Release Hunter",
+    description: "Stays on top of current music as it drops",
+    category: "signature",
+    minReviews: 10,
+  },
+  EMOTIONAL_LISTENER: {
+    id: "emotional_listener",
+    name: "Emotional Listener",
+    description: "Strong reactions reflected in rating variance",
+    category: "signature",
+    minReviews: 10,
+  },
+
+  // Rating Patterns
+  CRITICAL_EAR: {
+    id: "critical_ear",
+    name: "Critical Ear",
+    description: "Average rating below 5.5 ‚Äî high standards",
+    category: "rating",
+    minReviews: 15,
+  },
+  MUSIC_OPTIMIST: {
+    id: "music_optimist",
+    name: "Music Optimist",
+    description: "Average rating above 7.5 ‚Äî finds joy everywhere",
+    category: "rating",
+    minReviews: 15,
+  },
+  POLARIZED_TASTE: {
+    id: "polarized_taste",
+    name: "Polarized Taste",
+    description: "Bimodal ratings ‚Äî loves it or hates it",
+    category: "rating",
+    minReviews: 20,
+  },
+  PERFECTION_SEEKER: {
+    id: "perfection_seeker",
+    name: "Perfection Seeker",
+    description: "More 10s than near-perfect scores",
+    category: "rating",
+    minReviews: 15,
+  },
+
+  // Engagement Patterns
+  CONTRARIAN: {
+    id: "contrarian",
+    name: "Contrarian",
+    description: "Often differs 3+ points from consensus",
+    category: "engagement",
+    minReviews: 20,
+  },
+  HIDDEN_GEM_HUNTER: {
+    id: "hidden_gem_hunter",
+    name: "Hidden Gem Hunter",
+    description: "High ratings for low-popularity albums",
+    category: "engagement",
+    minReviews: 15,
+  },
+  DISCOGRAPHY_COMPLETIONIST: {
+    id: "discography_completionist",
+    name: "Discography Completionist",
+    description: "5+ albums from single artists",
+    category: "engagement",
+    minReviews: 20,
+  },
+  ARCHIVE_DIVER: {
+    id: "archive_diver",
+    name: "Archive Diver",
+    description: "Average album age over 15 years",
+    category: "engagement",
+    minReviews: 15,
+  },
+} as const
+
+export type PatternKey = keyof typeof TASTEID_PATTERNS
+
+interface PatternBadgeProps {
+  pattern: PatternKey
+  unlocked?: boolean
+  className?: string
+}
+
+const CATEGORY_COLORS = {
+  signature: "#60a5fa", // blue
+  rating: "#a78bfa", // violet
+  engagement: "#34d399", // emerald
+}
+
+export function PatternBadge({ pattern, unlocked = true, className = "" }: PatternBadgeProps) {
+  const patternData = TASTEID_PATTERNS[pattern]
+  const color = CATEGORY_COLORS[patternData.category]
+
+  if (!unlocked) {
+    return (
+      <div className={`border border-border p-3 opacity-50 ${className}`}>
+        <p className="text-xs font-bold text-muted-foreground">???</p>
+        <p className="text-[10px] text-muted-foreground/70 mt-1">
+          Unlocks at {patternData.minReviews} reviews
+        </p>
+      </div>
+    )
+  }
+
+  return (
+    <div
+      className={`border p-3 ${className}`}
+      style={{ borderColor: color }}
+    >
+      <p className="text-xs font-bold" style={{ color }}>
+        {patternData.name}
+      </p>
+      <p className="text-[10px] text-muted-foreground mt-1">{patternData.description}</p>
+    </div>
+  )
+}
+
+interface PatternGridProps {
+  unlockedPatterns: PatternKey[]
+  totalReviews: number
+  className?: string
+}
+
+export function PatternGrid({ unlockedPatterns, totalReviews, className = "" }: PatternGridProps) {
+  const allPatterns = Object.keys(TASTEID_PATTERNS) as PatternKey[]
+  const unlockedSet = new Set(unlockedPatterns)
+
+  // Group by category
+  const signaturePatterns = allPatterns.filter(p => TASTEID_PATTERNS[p].category === "signature")
+  const ratingPatterns = allPatterns.filter(p => TASTEID_PATTERNS[p].category === "rating")
+  const engagementPatterns = allPatterns.filter(p => TASTEID_PATTERNS[p].category === "engagement")
+
+  return (
+    <div className={className}>
+      {/* Signature Patterns */}
+      <div className="mb-6">
+        <p className="text-[10px] tracking-[0.2em] uppercase text-muted-foreground mb-3">
+          Signature Patterns
+        </p>
+        <div className="grid grid-cols-2 gap-2">
+          {signaturePatterns.map(pattern => (
+            <PatternBadge
+              key={pattern}
+              pattern={pattern}
+              unlocked={unlockedSet.has(pattern)}
+            />
+          ))}
+        </div>
+      </div>
+
+      {/* Rating Patterns */}
+      <div className="mb-6">
+        <p className="text-[10px] tracking-[0.2em] uppercase text-muted-foreground mb-3">
+          Rating Patterns
+        </p>
+        <div className="grid grid-cols-2 gap-2">
+          {ratingPatterns.map(pattern => (
+            <PatternBadge
+              key={pattern}
+              pattern={pattern}
+              unlocked={unlockedSet.has(pattern)}
+            />
+          ))}
+        </div>
+      </div>
+
+      {/* Engagement Patterns */}
+      <div>
+        <p className="text-[10px] tracking-[0.2em] uppercase text-muted-foreground mb-3">
+          Engagement Patterns
+        </p>
+        <div className="grid grid-cols-2 gap-2">
+          {engagementPatterns.map(pattern => (
+            <PatternBadge
+              key={pattern}
+              pattern={pattern}
+              unlocked={unlockedSet.has(pattern)}
+            />
+          ))}
+        </div>
+      </div>
+
+      {/* Progress indicator */}
+      <div className="mt-6 pt-4 border-t border-border">
+        <div className="flex justify-between text-xs text-muted-foreground">
+          <span>{unlockedPatterns.length} / {allPatterns.length} patterns unlocked</span>
+          <span>{totalReviews} reviews</span>
+        </div>
+        <div className="mt-2 h-1 bg-[--border] overflow-hidden">
+          <div
+            className="h-full bg-foreground transition-all"
+            style={{ width: `${(unlockedPatterns.length / allPatterns.length) * 100}%` }}
+          />
+        </div>
+      </div>
+    </div>
+  )
+}
+
+// Compact inline display of unlocked patterns
+export function PatternList({ patterns, className = "" }: { patterns: PatternKey[], className?: string }) {
+  if (patterns.length === 0) return null
+
+  return (
+    <div className={`flex flex-wrap gap-2 ${className}`}>
+      {patterns.map(pattern => {
+        const data = TASTEID_PATTERNS[pattern]
+        const color = CATEGORY_COLORS[data.category]
+        return (
+          <span
+            key={pattern}
+            className="text-[10px] px-2 py-1 border"
+            style={{ borderColor: color, color }}
+          >
+            {data.name}
+          </span>
+        )
+      })}
+    </div>
+  )
+}
diff --git a/src/components/tasteid/PolarityScore.tsx b/src/components/tasteid/PolarityScore.tsx
new file mode 100644
index 0000000..48385b1
--- /dev/null
+++ b/src/components/tasteid/PolarityScore.tsx
@@ -0,0 +1,220 @@
+"use client"
+
+// TasteID Polarity Score 2.0
+// The enhanced Polarity Score combines multiple dimensions into a single identity strength metric
+
+interface PolarityScoreProps {
+  score: number // 0-1
+  signatureStrength?: number
+  patternDiversity?: number
+  consolidationScore?: number
+  uniquenessScore?: number
+  engagementDepth?: number
+  className?: string
+  showBreakdown?: boolean
+}
+
+// Score interpretation thresholds from the doc
+const SCORE_LEVELS = [
+  { threshold: 0.8, label: "Highly Distinct", description: "Unmistakable listening identity", color: "#22c55e" },
+  { threshold: 0.6, label: "Well-Defined", description: "Clear patterns and preferences", color: "#60a5fa" },
+  { threshold: 0.4, label: "Emerging", description: "Patterns forming, more data helpful", color: "#fbbf24" },
+  { threshold: 0, label: "Nascent", description: "Early stage, keep reviewing", color: "#a78bfa" },
+]
+
+function getScoreLevel(score: number) {
+  return SCORE_LEVELS.find(level => score >= level.threshold) || SCORE_LEVELS[SCORE_LEVELS.length - 1]
+}
+
+export function PolarityScore({
+  score,
+  signatureStrength,
+  patternDiversity,
+  consolidationScore,
+  uniquenessScore,
+  engagementDepth,
+  className = "",
+  showBreakdown = true,
+}: PolarityScoreProps) {
+  const level = getScoreLevel(score)
+  const displayScore = Math.round(score * 100)
+
+  return (
+    <div className={`border border-border p-4 ${className}`}>
+      <div className="flex items-center justify-between mb-4">
+        <div>
+          <p className="text-[10px] tracking-[0.2em] uppercase text-muted-foreground">
+            Polarity Score 2.0
+          </p>
+          <p className="text-xs text-muted-foreground/70 mt-1">
+            Identity strength metric
+          </p>
+        </div>
+        <div className="text-right">
+          <p className="text-3xl font-bold" style={{ color: level.color }}>
+            {displayScore}
+          </p>
+          <p className="text-xs" style={{ color: level.color }}>
+            {level.label}
+          </p>
+        </div>
+      </div>
+
+      {/* Score bar */}
+      <div className="mb-4">
+        <div className="h-2 bg-border overflow-hidden">
+          <div
+            className="h-full transition-all duration-500"
+            style={{
+              width: `${displayScore}%`,
+              backgroundColor: level.color,
+            }}
+          />
+        </div>
+        <p className="text-xs text-muted-foreground/70 mt-2">{level.description}</p>
+      </div>
+
+      {/* Score breakdown */}
+      {showBreakdown && (
+        <div className="pt-4 border-t border-border">
+          <p className="text-[10px] tracking-[0.15em] uppercase text-muted-foreground mb-3">
+            Formula Components
+          </p>
+          <div className="space-y-2 text-xs">
+            {signatureStrength !== undefined && (
+              <ScoreRow
+                label="Signature Strength"
+                value={signatureStrength}
+                weight={0.25}
+                description="Network activation clarity"
+              />
+            )}
+            {patternDiversity !== undefined && (
+              <ScoreRow
+                label="Pattern Diversity"
+                value={patternDiversity}
+                weight={0.20}
+                description="Number of detected patterns"
+              />
+            )}
+            {consolidationScore !== undefined && (
+              <ScoreRow
+                label="Consolidation"
+                value={consolidationScore}
+                weight={0.20}
+                description="Taste stability"
+              />
+            )}
+            {uniquenessScore !== undefined && (
+              <ScoreRow
+                label="Uniqueness"
+                value={uniquenessScore}
+                weight={0.20}
+                description="Deviation from typical"
+              />
+            )}
+            {engagementDepth !== undefined && (
+              <ScoreRow
+                label="Engagement Depth"
+                value={engagementDepth}
+                weight={0.15}
+                description="Review depth & length"
+              />
+            )}
+          </div>
+        </div>
+      )}
+
+      {/* Score interpretation legend */}
+      <div className="mt-4 pt-4 border-t border-border">
+        <p className="text-[10px] tracking-[0.15em] uppercase text-muted-foreground mb-3">
+          Score Interpretation
+        </p>
+        <div className="grid grid-cols-2 gap-2">
+          {SCORE_LEVELS.map((lvl, i) => (
+            <div key={i} className="flex items-center gap-2">
+              <div
+                className="w-2 h-2"
+                style={{ backgroundColor: lvl.color }}
+              />
+              <span className="text-xs text-muted-foreground">
+                {lvl.threshold * 100}+ ‚Äî {lvl.label}
+              </span>
+            </div>
+          ))}
+        </div>
+      </div>
+    </div>
+  )
+}
+
+function ScoreRow({
+  label,
+  value,
+  weight,
+  description,
+}: {
+  label: string
+  value: number
+  weight: number
+  description: string
+}) {
+  return (
+    <div className="flex items-center justify-between">
+      <div className="flex items-center gap-2">
+        <span className="text-muted-foreground/70">{label}</span>
+        <span className="text-[9px] text-muted-foreground">√ó{weight}</span>
+      </div>
+      <div className="flex items-center gap-2">
+        <div className="w-16 h-1 bg-border overflow-hidden">
+          <div
+            className="h-full bg-foreground"
+            style={{ width: `${value * 100}%` }}
+          />
+        </div>
+        <span className="w-8 text-right text-muted-foreground">{Math.round(value * 100)}</span>
+      </div>
+    </div>
+  )
+}
+
+// Compact inline Polarity Score
+export function PolarityScoreBadge({ score, className = "" }: { score: number, className?: string }) {
+  const level = getScoreLevel(score)
+  const displayScore = Math.round(score * 100)
+
+  return (
+    <span
+      className={`inline-flex items-center gap-2 px-2 py-1 border ${className}`}
+      style={{ borderColor: level.color }}
+    >
+      <span className="text-xs font-bold" style={{ color: level.color }}>
+        {displayScore}
+      </span>
+      <span className="text-[10px] text-muted-foreground">{level.label}</span>
+    </span>
+  )
+}
+
+// Calculate Polarity Score 2.0 from components
+export function calculatePolarityScore({
+  signatureStrength,
+  patternDiversity,
+  consolidationScore,
+  uniquenessScore,
+  engagementDepth,
+}: {
+  signatureStrength: number
+  patternDiversity: number
+  consolidationScore: number
+  uniquenessScore: number
+  engagementDepth: number
+}): number {
+  return (
+    (signatureStrength * 0.25) +
+    (patternDiversity * 0.20) +
+    (consolidationScore * 0.20) +
+    (uniquenessScore * 0.20) +
+    (engagementDepth * 0.15)
+  )
+}
diff --git a/src/components/tasteid/TasteConsolidation.tsx b/src/components/tasteid/TasteConsolidation.tsx
new file mode 100644
index 0000000..b41e2e3
--- /dev/null
+++ b/src/components/tasteid/TasteConsolidation.tsx
@@ -0,0 +1,169 @@
+"use client"
+
+// TasteID Taste Consolidation - tracks "sticky" vs "fading" tastes
+// Inspired by memory consolidation in neuroscience
+
+export type ConsolidationTrend = "strengthening" | "fading" | "stable"
+
+interface ConsolidatedTaste {
+  name: string
+  type: "genre" | "artist"
+  trend: ConsolidationTrend
+  recentAvg: number
+  olderAvg: number
+  totalReviews: number
+}
+
+interface TasteConsolidationProps {
+  consolidatedTastes: ConsolidatedTaste[]
+  className?: string
+}
+
+const TREND_COLORS = {
+  strengthening: "#22c55e", // green
+  fading: "#f87171", // red
+  stable: "#60a5fa", // blue
+}
+
+const TREND_LABELS = {
+  strengthening: "‚Üë STRENGTHENING",
+  fading: "‚Üì FADING",
+  stable: "‚Üí STABLE",
+}
+
+export function TasteConsolidation({ consolidatedTastes, className = "" }: TasteConsolidationProps) {
+  const genres = consolidatedTastes.filter(t => t.type === "genre")
+  const artists = consolidatedTastes.filter(t => t.type === "artist")
+
+  return (
+    <div className={className}>
+      <div className="mb-4">
+        <p className="text-[10px] tracking-[0.2em] uppercase text-muted-foreground mb-1">
+          Taste Consolidation
+        </p>
+        <p className="text-xs text-muted-foreground/70">
+          Tracking which tastes are "sticking" vs "fading" over time
+        </p>
+      </div>
+
+      {/* How it works */}
+      <div className="mb-6 p-3 border border-border bg-muted/10">
+        <p className="text-[10px] tracking-[0.15em] uppercase text-muted-foreground mb-2">How it works</p>
+        <p className="text-xs text-muted-foreground/70">
+          Reviews are split into recent (last 6 months) and older. Genres and artists
+          that appear consistently with good ratings are "consolidated."
+        </p>
+        <div className="flex gap-4 mt-3">
+          {(["strengthening", "fading", "stable"] as ConsolidationTrend[]).map(trend => (
+            <span
+              key={trend}
+              className="text-[9px] font-bold"
+              style={{ color: TREND_COLORS[trend] }}
+            >
+              {TREND_LABELS[trend]}
+            </span>
+          ))}
+        </div>
+      </div>
+
+      {/* Consolidated Genres */}
+      {genres.length > 0 && (
+        <div className="mb-6">
+          <p className="text-xs font-bold mb-3">Genres</p>
+          <div className="space-y-2">
+            {genres.map((taste, i) => (
+              <ConsolidationRow key={i} taste={taste} />
+            ))}
+          </div>
+        </div>
+      )}
+
+      {/* Consolidated Artists */}
+      {artists.length > 0 && (
+        <div>
+          <p className="text-xs font-bold mb-3">Artists</p>
+          <div className="space-y-2">
+            {artists.map((taste, i) => (
+              <ConsolidationRow key={i} taste={taste} />
+            ))}
+          </div>
+        </div>
+      )}
+
+      {consolidatedTastes.length === 0 && (
+        <div className="text-center py-8 text-muted-foreground">
+          <p className="text-sm">Not enough data yet</p>
+          <p className="text-xs mt-1">Review more albums across different time periods</p>
+        </div>
+      )}
+
+      {/* Thresholds explanation */}
+      <div className="mt-6 pt-4 border-t border-border">
+        <p className="text-[10px] tracking-[0.15em] uppercase text-muted-foreground mb-3">
+          Consolidation Thresholds
+        </p>
+        <div className="grid grid-cols-2 gap-y-2 text-xs">
+          <span className="text-muted-foreground">‚â•2</span>
+          <span className="text-muted-foreground/70">Reviews per period for genre</span>
+          <span className="text-muted-foreground">‚â•3</span>
+          <span className="text-muted-foreground/70">Total reviews for artist</span>
+          <span className="text-muted-foreground">‚â•6</span>
+          <span className="text-muted-foreground/70">Avg rating for consolidated</span>
+          <span className="text-muted-foreground">¬±0.5</span>
+          <span className="text-muted-foreground/70">Rating diff for trend</span>
+        </div>
+      </div>
+    </div>
+  )
+}
+
+function ConsolidationRow({ taste }: { taste: ConsolidatedTaste }) {
+  const color = TREND_COLORS[taste.trend]
+  const diff = taste.recentAvg - taste.olderAvg
+
+  return (
+    <div className="flex items-center justify-between p-2 border border-border">
+      <div className="flex items-center gap-3">
+        <span
+          className="text-[9px] font-bold w-24"
+          style={{ color }}
+        >
+          {TREND_LABELS[taste.trend]}
+        </span>
+        <span className="text-sm font-medium">{taste.name}</span>
+      </div>
+      <div className="flex items-center gap-4 text-xs text-muted-foreground">
+        <span>Recent: {taste.recentAvg.toFixed(1)}</span>
+        <span>Older: {taste.olderAvg.toFixed(1)}</span>
+        <span style={{ color: diff > 0 ? "#22c55e" : diff < 0 ? "#f87171" : "#60a5fa" }}>
+          {diff > 0 ? "+" : ""}{diff.toFixed(1)}
+        </span>
+      </div>
+    </div>
+  )
+}
+
+// Compact summary of consolidation status
+export function ConsolidationSummary({
+  strengthening,
+  fading,
+  stable
+}: {
+  strengthening: number
+  fading: number
+  stable: number
+}) {
+  return (
+    <div className="flex items-center gap-4 text-xs">
+      <span style={{ color: TREND_COLORS.strengthening }}>
+        ‚Üë {strengthening}
+      </span>
+      <span style={{ color: TREND_COLORS.stable }}>
+        ‚Üí {stable}
+      </span>
+      <span style={{ color: TREND_COLORS.fading }}>
+        ‚Üì {fading}
+      </span>
+    </div>
+  )
+}
diff --git a/src/components/tasteid/index.ts b/src/components/tasteid/index.ts
index d9302a0..8db8570 100644
--- a/src/components/tasteid/index.ts
+++ b/src/components/tasteid/index.ts
@@ -1,3 +1,6 @@
+// TasteID Components - Powered by Polarity 1.2
+// How WaxFeed understands your music taste
+
 export { ArchetypeBadge, ArchetypeBadgeSkeleton } from './ArchetypeBadge'
 export { GenreRadarChart, GenreRadarChartSkeleton } from './GenreRadarChart'
 export { CompatibilityMeter, CompatibilityMeterSkeleton } from './CompatibilityMeter'
@@ -5,3 +8,37 @@ export { TasteIDCard, TasteIDCardSkeleton } from './TasteIDCard'
 export { TasteComparison, TasteComparisonSkeleton } from './TasteComparison'
 export { ArtistDNAStrip, ArtistDNAStripSkeleton } from './ArtistDNAStrip'
 export { TasteCardShare } from './TasteCardShare'
+
+// New TasteID components based on Polarity 1.2 architecture
+export {
+  MusicNetworksVisualization,
+  MusicNetworksMini,
+  MusicNetworksLegend,
+  MusicNetworksSkeleton,
+  MUSIC_NETWORKS,
+  type MusicNetworkKey,
+} from "./MusicNetworks"
+
+export {
+  ListeningModeIndicator,
+  ListeningModeBadge,
+} from "./ListeningModeIndicator"
+
+export {
+  PatternBadge,
+  PatternGrid,
+  PatternList,
+  TASTEID_PATTERNS,
+  type PatternKey,
+} from "./PatternBadges"
+
+export {
+  TasteConsolidation,
+  ConsolidationSummary,
+} from "./TasteConsolidation"
+
+export {
+  PolarityScore,
+  PolarityScoreBadge,
+  calculatePolarityScore,
+} from "./PolarityScore"
-- 
2.50.1 (Apple Git-155)

