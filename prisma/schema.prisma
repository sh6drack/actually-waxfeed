// Waxfeed Database Schema
// Social music review platform - "Letterboxd for music"

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER ROLES
// ============================================

enum UserRole {
  USER // Regular user
  PREMIUM // Premium subscriber - all features unlocked
  ADMIN // Admin - all features + admin panel access
}

enum SubTier {
  FREE
  WAX_PLUS
  WAX_PRO
}

enum TxType {
  DAILY_CLAIM
  STREAK_BONUS
  REVIEW_REWARD
  WAX_RECEIVED
  FIRST_ALBUM_BONUS
  REFERRAL_BONUS
  SUBSCRIPTION_GRANT
  PURCHASE
  AWARD_STANDARD
  AWARD_PREMIUM
  AWARD_GOLD
  BOOST_REVIEW
  BUY_BADGE
  BUY_FRAME
  USERNAME_CHANGE
  TRENDING_BONUS
}

enum PurchaseType {
  SUBSCRIPTION
  WAX_PAX
  USERNAME_CHANGE
}

enum PurchaseStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum ItemType {
  BADGE
  FRAME
  THEME
  BOOST
}

// ============================================
// USER & AUTHENTICATION
// ============================================

model User {
  id                  String    @id @default(cuid())
  email               String    @unique
  password            String? // Hashed password for credentials auth
  emailVerified       DateTime?
  username            String?   @unique
  name                String?
  image               String?
  bio                 String?   @db.VarChar(150)
  country             String?   // ISO 3166-1 alpha-2 code (e.g., "US", "GB", "DE")
  socialLinks         Json? // { instagram, twitter, spotify, etc. }
  role                UserRole  @default(USER)
  waxScore            Int       @default(0)
  premiumWaxScore     Int       @default(0)
  isPremium           Boolean   @default(false)
  premiumExpiresAt    DateTime?
  isVerified          Boolean   @default(false)
  verifiedAt          DateTime?
  usernameChangesUsed Int       @default(0)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  // Streak tracking
  currentStreak  Int       @default(0)
  longestStreak  Int       @default(0)
  lastReviewDate DateTime?

  // ============================================
  // FIRST SPIN - Tastemaker Score
  // ============================================
  tastemakeScore  Int @default(0) // Gold×10 + Silver×5 + Bronze×2
  goldSpinCount   Int @default(0)
  silverSpinCount Int @default(0)
  bronzeSpinCount Int @default(0)

  // ============================================
  // WAX WALLET & MONETIZATION
  // ============================================
  waxBalance        Int @default(0) // Spendable Wax currency
  lifetimeWaxEarned Int @default(0) // Total Wax ever earned
  lifetimeWaxSpent  Int @default(0) // Total Wax ever spent
  goldWaxScore      Int @default(0) // Gold wax received (for display)

  // Subscription & Stripe
  subscriptionTier     SubTier @default(FREE)
  stripeCustomerId     String? @unique
  stripeSubscriptionId String?

  // Daily rewards tracking
  dailyClaimedAt       DateTime?
  dailyReviewClaimedAt DateTime? // Track first review of day bonus

  // Weekly earning cap (free users)
  weeklyWaxEarned Int      @default(0)
  weeklyResetAt   DateTime @default(now())

  // Referral system
  referralCode String? @unique
  referredBy   String? // User ID who referred them

  // Auth relations (NextAuth)
  accounts Account[]
  sessions Session[]

  // Content relations
  reviews      Review[]
  trackReviews TrackReview[]
  replies      Reply[]
  lists        List[]
  reviewDrafts ReviewDraft[]

  // Social relations (friends only)
  friendRequestsSent     FriendRequest[] @relation("sender")
  friendRequestsReceived FriendRequest[] @relation("receiver")
  friendshipsAsUser1     Friendship[]    @relation("user1")
  friendshipsAsUser2     Friendship[]    @relation("user2")

  // Engagement relations
  reviewLikes     ReviewLike[]
  reviewReactions ReviewReaction[]
  replyLikes      ReplyLike[]
  listLikes       ListLike[]
  listComments    ListComment[]
  waxGiven        WaxAward[]       @relation("giver")

  // Moderation relations
  blocksInitiated  Block[]        @relation("blocker")
  blocksReceived   Block[]        @relation("blocked")
  reportsSubmitted Report[]       @relation("reporter")
  notifications    Notification[]

  // Notification settings
  notificationSettings NotificationSettings?

  // Pinned content
  pinnedReviewId String?
  pinnedListId   String?

  // Hot takes relations
  hotTakes         HotTake[]
  hotTakeVotes     HotTakeVote[]
  hotTakeArguments HotTakeArgument[]

  // TasteID relation
  tasteId TasteID?

  // Monetization relations
  waxTransactions WaxTransaction[]
  purchases       Purchase[]
  userItems       UserItem[]

  // College Radio Station membership
  stationMemberships StationMember[]

  // Social Messaging relations
  conversationsAsUser1 Conversation[]  @relation("convUser1")
  conversationsAsUser2 Conversation[]  @relation("convUser2")
  messagesSent         Message[]       @relation("messageSender")
  roomMessagesSent     RoomMessage[]   @relation("roomMessageSender")
  circleMessagesSent   CircleMessage[] @relation("circleMessageSender")

  // First Spin badges
  firstSpinBadges FirstSpinBadge[]

  @@index([username])
  @@index([email])
  @@index([createdAt])
  @@index([stripeCustomerId])
  @@index([subscriptionTier])
  @@index([referralCode])
}

// NextAuth required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================
// ALBUMS & ARTISTS
// ============================================

model Album {
  id                   String   @id @default(cuid())
  spotifyId            String   @unique
  title                String
  artistName           String
  artistSpotifyId      String?
  releaseDate          DateTime
  releaseDatePrecision String   @default("day") // day, month, year
  coverArtUrl          String?
  coverArtUrlSmall     String? // 64px
  coverArtUrlMedium    String? // 300px
  coverArtUrlLarge     String? // 640px
  genres               String[] // From Spotify
  albumType            String   @default("album") // album, single, ep, compilation
  totalTracks          Int      @default(0)
  spotifyUrl           String?
  appleMusicUrl        String?
  tidalUrl             String?
  youtubeMusicUrl      String?

  // Billboard tracking
  billboardRank Int? // Current Billboard 200 position (null if not on chart)
  billboardDate DateTime? // Date of the chart position

  // ============================================
  // FIRST SPIN - Trending detection
  // ============================================
  isTrending     Boolean   @default(false) // Has this album hit trending threshold?
  trendedAt      DateTime? // When it first trended
  trendThreshold Int       @default(100) // Reviews needed to trend (can vary)

  // Cached stats
  averageRating      Float?
  totalReviews       Int    @default(0)
  totalRatings       Int    @default(0)
  ratingDistribution Json? // { "0": 5, "1": 3, ... "10": 20 }

  // Timestamps
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  lastSyncedAt DateTime @default(now())

  // Relations
  reviews         Review[]
  listItems       ListItem[]
  tracks          Track[]
  userTags        AlbumTag[]
  hotTakes        HotTake[]
  albumRoom       AlbumRoom?
  messageContext  Message[]        @relation("messageAlbumContext")
  firstSpinBadges FirstSpinBadge[]

  @@index([spotifyId])
  @@index([artistName])
  @@index([releaseDate])
  @@index([averageRating])
  @@index([totalReviews])
  @@index([billboardRank])
}

model Track {
  id          String  @id @default(cuid())
  spotifyId   String  @unique
  albumId     String
  name        String
  trackNumber Int
  discNumber  Int     @default(1)
  durationMs  Int
  previewUrl  String? // 30-second Spotify preview
  spotifyUrl  String?

  // Aggregate stats
  averageRating Float? // Computed average from reviews
  totalReviews  Int    @default(0)

  album   Album         @relation(fields: [albumId], references: [id], onDelete: Cascade)
  lyrics  Lyrics?
  reviews TrackReview[]

  @@index([albumId])
  @@index([averageRating])
}

// ============================================
// TRACK REVIEWS - Individual song ratings
// ============================================

model TrackReview {
  id         String   @id @default(cuid())
  userId     String
  trackId    String
  rating     Float // 0-10 scale (half-point precision)
  text       String?  @db.VarChar(1000) // Optional short note (shorter than album reviews)
  isFavorite Boolean  @default(false) // Mark as standout track
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  track Track @relation(fields: [trackId], references: [id], onDelete: Cascade)

  @@unique([userId, trackId])
  @@index([userId])
  @@index([trackId])
  @@index([rating])
  @@index([createdAt])
}

model Artist {
  id           String   @id @default(cuid())
  spotifyId    String   @unique
  name         String
  imageUrl     String?
  genres       String[]
  popularity   Int?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  lastSyncedAt DateTime @default(now())

  @@index([spotifyId])
  @@index([name])
}

model AlbumTag {
  id        String   @id @default(cuid())
  albumId   String
  userId    String
  tag       String   @db.VarChar(50)
  createdAt DateTime @default(now())

  album Album @relation(fields: [albumId], references: [id], onDelete: Cascade)

  @@unique([albumId, userId, tag])
  @@index([albumId])
  @@index([tag])
}

// ============================================
// REVIEWS & RATINGS
// ============================================

model Review {
  id          String   @id @default(cuid())
  userId      String
  albumId     String
  rating      Float // 0-10, supports decimals like 7.5
  text        String?  @db.Text // 5000 char limit enforced in app
  vibes       String[] // Vibe tags for TasteID Polarity Model (e.g., ["energetic", "hype"])
  isEdited    Boolean  @default(false)
  editHistory Json? // [{ text, rating, editedAt }]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // ============================================
  // FIRST SPIN - Review position tracking
  // ============================================
  reviewPosition Int? // 1 = first reviewer, 2 = second, etc.

  // Stats
  likeCount       Int @default(0)
  waxCount        Int @default(0)
  premiumWaxCount Int @default(0)
  goldWaxCount    Int @default(0)
  replyCount      Int @default(0)

  // Boost system
  isBoosted      Boolean   @default(false)
  boostExpiresAt DateTime?

  // Reaction counts
  fireCount          Int @default(0)
  insightfulCount    Int @default(0)
  funnyCount         Int @default(0)
  controversialCount Int @default(0)

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  album Album @relation(fields: [albumId], references: [id], onDelete: Cascade)

  replies   Reply[]
  likes     ReviewLike[]
  reactions ReviewReaction[]
  waxAwards WaxAward[]

  @@unique([userId, albumId])
  @@index([userId])
  @@index([albumId])
  @@index([createdAt])
  @@index([likeCount])
  @@index([rating])
  @@index([reviewPosition])
}

model ReviewDraft {
  id        String   @id @default(cuid())
  userId    String
  albumId   String
  rating    Float?
  text      String?  @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, albumId])
  @@index([userId])
}

model Reply {
  id          String   @id @default(cuid())
  reviewId    String
  userId      String
  text        String   @db.Text // 2000 char limit enforced in app
  isEdited    Boolean  @default(false)
  editHistory Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  likeCount Int @default(0)

  review Review      @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  user   User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  likes  ReplyLike[]

  @@index([reviewId])
  @@index([userId])
  @@index([createdAt])
  @@index([likeCount])
}

model ReviewLike {
  id        String   @id @default(cuid())
  reviewId  String
  userId    String
  createdAt DateTime @default(now())

  review Review @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([reviewId, userId])
  @@index([reviewId])
  @@index([userId])
}

model ReviewReaction {
  id        String   @id @default(cuid())
  reviewId  String
  userId    String
  type      String // "fire", "insightful", "funny", "controversial"
  createdAt DateTime @default(now())

  review Review @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([reviewId, userId, type])
  @@index([reviewId])
  @@index([userId])
  @@index([type])
}

model ReplyLike {
  id        String   @id @default(cuid())
  replyId   String
  userId    String
  createdAt DateTime @default(now())

  reply Reply @relation(fields: [replyId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([replyId, userId])
  @@index([replyId])
  @@index([userId])
}

// ============================================
// LISTS
// ============================================

model List {
  id            String    @id @default(cuid())
  userId        String
  title         String    @db.VarChar(200)
  description   String?   @db.Text
  isRanked      Boolean   @default(true)
  isPublic      Boolean   @default(true)
  allowRemix    Boolean   @default(true)
  remixedFromId String? // If this list was remixed from another
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  publishedAt   DateTime?

  likeCount    Int @default(0)
  commentCount Int @default(0)

  user        User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  remixedFrom List?  @relation("remixes", fields: [remixedFromId], references: [id])
  remixes     List[] @relation("remixes")

  items              ListItem[]
  likes              ListLike[]
  comments           ListComment[]
  reorderSuggestions ListReorderSuggestion[]

  @@index([userId])
  @@index([createdAt])
  @@index([likeCount])
  @@index([isPublic])
  @@index([userId, createdAt]) // For user's lists sorted by date
}

model ListItem {
  id       String  @id @default(cuid())
  listId   String
  albumId  String
  position Int
  notes    String? @db.Text

  list  List  @relation(fields: [listId], references: [id], onDelete: Cascade)
  album Album @relation(fields: [albumId], references: [id], onDelete: Cascade)

  @@unique([listId, albumId])
  @@index([listId])
  @@index([position])
}

model ListLike {
  id        String   @id @default(cuid())
  listId    String
  userId    String
  createdAt DateTime @default(now())

  list List @relation(fields: [listId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([listId, userId])
  @@index([listId])
  @@index([userId])
}

model ListComment {
  id        String   @id @default(cuid())
  listId    String
  userId    String
  text      String   @db.Text
  isEdited  Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  list List @relation(fields: [listId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([listId])
  @@index([userId])
}

model ListReorderSuggestion {
  id             String   @id @default(cuid())
  listId         String
  suggesterId    String
  suggestedOrder Json // Array of album IDs in suggested order
  rationale      String   @db.Text
  status         String   @default("pending") // pending, accepted, rejected
  createdAt      DateTime @default(now())

  list List @relation(fields: [listId], references: [id], onDelete: Cascade)

  @@index([listId])
  @@index([status])
}

// ============================================
// SOCIAL (Friends Only)
// ============================================

model FriendRequest {
  id          String    @id @default(cuid())
  senderId    String
  receiverId  String
  status      String    @default("pending") // pending, accepted, rejected
  createdAt   DateTime  @default(now())
  respondedAt DateTime?

  sender   User @relation("sender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("receiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@index([senderId])
  @@index([receiverId])
  @@index([status])
}

model Friendship {
  id        String   @id @default(cuid())
  user1Id   String
  user2Id   String
  createdAt DateTime @default(now())

  user1 User @relation("user1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2 User @relation("user2", fields: [user2Id], references: [id], onDelete: Cascade)

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
}

model Block {
  id        String   @id @default(cuid())
  blockerId String
  blockedId String
  createdAt DateTime @default(now())

  blocker User @relation("blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
}

// ============================================
// WAX SYSTEM
// ============================================

model WaxAward {
  id        String   @id @default(cuid())
  reviewId  String
  giverId   String
  waxType   String   @default("standard") // standard, premium, gold
  waxCost   Int      @default(0) // How much wax it cost to give
  createdAt DateTime @default(now())

  review Review @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  giver  User   @relation("giver", fields: [giverId], references: [id], onDelete: Cascade)

  @@unique([reviewId, giverId])
  @@index([reviewId])
  @@index([giverId])
  @@index([waxType])
}

// ============================================
// NOTIFICATIONS
// ============================================

model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String // reply, like, friend_request, friend_accept, review_trending, friend_review
  content   Json // { actorId, actorName, reviewId, albumTitle, etc. }
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
  @@index([userId, isRead, createdAt]) // Compound index for common query pattern
}

model NotificationSettings {
  id             String  @id @default(cuid())
  userId         String  @unique
  replies        Boolean @default(true)
  likes          Boolean @default(true)
  friendRequests Boolean @default(true)
  friendReviews  Boolean @default(true)
  reviewTrending Boolean @default(true)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// ============================================
// MODERATION
// ============================================

model Report {
  id          String    @id @default(cuid())
  reporterId  String
  contentType String // review, reply, list, user
  contentId   String
  reason      String // spam, offensive, harassment, other
  details     String?   @db.Text
  status      String    @default("pending") // pending, reviewed, resolved, dismissed
  createdAt   DateTime  @default(now())
  resolvedAt  DateTime?
  resolvedBy  String?

  reporter User @relation("reporter", fields: [reporterId], references: [id], onDelete: Cascade)

  @@index([reporterId])
  @@index([contentType])
  @@index([status])
}

// ============================================
// ANALYTICS (for Year-End features)
// ============================================

model UserYearlyStats {
  id                 String @id @default(cuid())
  userId             String
  year               Int
  totalReviews       Int    @default(0)
  totalLists         Int    @default(0)
  averageRating      Float?
  topGenres          Json? // [{ genre, count }]
  topArtists         Json? // [{ artistName, count }]
  ratingDistribution Json? // { "0": 1, ... "10": 5 }
  monthlyActivity    Json? // { "1": 5, "2": 10, ... }

  @@unique([userId, year])
  @@index([userId])
  @@index([year])
}

// ============================================
// SPOTIFY API CACHE
// ============================================

model SpotifyCache {
  id        String   @id @default(cuid())
  key       String   @unique // e.g., "album:spotifyId" or "search:query"
  data      Json
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([key])
  @@index([expiresAt])
}

// ============================================
// LYRICS CACHE
// ============================================

model Lyrics {
  id           String   @id @default(cuid())
  trackId      String   @unique // Our internal track ID
  geniusId     String? // Genius song ID for linking
  geniusUrl    String? // Link to Genius page
  lyrics       String?  @db.Text // The actual lyrics text
  syncedLyrics Json? // Synced/timed lyrics if available
  source       String   @default("genius") // genius, musixmatch, etc
  notFound     Boolean  @default(false) // True if we searched and found nothing
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  track Track @relation(fields: [trackId], references: [id], onDelete: Cascade)

  @@index([trackId])
  @@index([geniusId])
}

// ============================================
// HOT TAKES (Community Debates)
// ============================================

model HotTake {
  id        String   @id @default(cuid())
  albumId   String
  authorId  String
  stance    String // OVERRATED, UNDERRATED, MASTERPIECE, TRASH, AHEAD_OF_TIME, DATED
  content   String   @db.VarChar(280)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Cached counts for performance
  voteCount Int @default(0)

  album     Album             @relation(fields: [albumId], references: [id], onDelete: Cascade)
  author    User              @relation(fields: [authorId], references: [id], onDelete: Cascade)
  votes     HotTakeVote[]
  arguments HotTakeArgument[]

  @@unique([albumId, authorId]) // One hot take per album per user
  @@index([albumId])
  @@index([authorId])
  @@index([createdAt])
  @@index([voteCount])
  @@index([stance])
}

model HotTakeVote {
  id        String   @id @default(cuid())
  hotTakeId String
  userId    String
  vote      String // agree, disagree
  createdAt DateTime @default(now())

  hotTake HotTake @relation(fields: [hotTakeId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([hotTakeId, userId])
  @@index([hotTakeId])
  @@index([userId])
  @@index([vote])
}

model HotTakeArgument {
  id        String   @id @default(cuid())
  hotTakeId String
  authorId  String
  side      String // agree, disagree
  content   String   @db.VarChar(500)
  likes     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  hotTake HotTake @relation(fields: [hotTakeId], references: [id], onDelete: Cascade)
  author  User    @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([hotTakeId])
  @@index([authorId])
  @@index([side])
  @@index([likes])
}

// ============================================
// TASTEID - Music Taste Fingerprint System
// ============================================

model TasteID {
  id     String @id @default(cuid())
  userId String @unique

  // Core taste vectors
  genreVector       Json // { "hip-hop": 0.85, "jazz": 0.72, ... } - 0-1 affinities
  artistDNA         Json // Top 20 defining artists with weights
  decadePreferences Json // { "1990s": 0.6, "2000s": 0.4, ... }

  // Archetype classification
  primaryArchetype    String // "Hip-Hop Head", "Jazz Explorer", etc.
  secondaryArchetype  String? // Optional secondary classification
  archetypeConfidence Float   @default(0) // 0-1 confidence in classification

  // Behavioral metrics
  adventurenessScore Float  @default(0.5) // 0-1, how diverse their taste is
  ratingSkew         String @default("balanced") // "harsh" | "lenient" | "balanced"
  averageRating      Float  @default(5)
  ratingStdDev       Float  @default(0) // Standard deviation of ratings

  // Engagement signals
  reviewDepth     String @default("rater") // "rater" | "writer" | "essayist"
  reviewCount     Int    @default(0)
  avgReviewLength Int    @default(0) // Average word count

  // Computed display data
  topGenres       String[] // Top 5 genres for display
  topArtists      String[] // Top 10 artists for display
  signatureAlbums String[] // Album IDs that define their taste

  // Polarity Points - Bayesian edge strength from CCX
  polarityScore Float @default(0) // Overall taste distinctiveness

  // Polarity 1.2 - Cognitive modeling for music
  listeningSignature   Json? // { "discovery": 0.35, "comfort": 0.22, ... } - Music network activation baseline
  signaturePatterns    String[] // Detected patterns: ["Discovery↔Comfort Oscillation", "Deep Dive Sprints"]
  memorableMoments     Json? // Episodic memory: notable rating moments (first 10, first 0, etc.)
  futureSelvesMusic    Json? // Prospective musical trajectories and skill trees
  consolidationHistory Json? // How taste has consolidated over time
  polarityScore2       Float? // Enhanced Polarity 1.2 score with cognitive factors

  // Vocabulary Analysis - Word/sentiment analysis from review text (Nathan's request)
  vocabularyProfile    Json? // { writingStyle, dominantMood, keyDescriptors, musicVocabulary, etc. }

  // Timestamps
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  lastComputedAt DateTime @default(now())

  // Relations
  user           User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  snapshots      TasteIDSnapshot[]
  matchesAsUser1 TasteMatch[]      @relation("tasteUser1")
  matchesAsUser2 TasteMatch[]      @relation("tasteUser2")

  @@index([primaryArchetype])
  @@index([adventurenessScore])
  @@index([polarityScore])
}

model TasteIDSnapshot {
  id        String @id @default(cuid())
  tasteIdId String

  // Snapshot of taste state
  genreVector        Json
  artistDNA          Json
  primaryArchetype   String
  adventurenessScore Float
  reviewCount        Int

  // Polarity 1.2 - Listening signature snapshot for drift tracking
  listeningSignature Json?
  polarityScore2     Float?

  // When this snapshot was taken
  month     Int // 1-12
  year      Int
  createdAt DateTime @default(now())

  tasteId TasteID @relation(fields: [tasteIdId], references: [id], onDelete: Cascade)

  @@unique([tasteIdId, year, month])
  @@index([tasteIdId])
  @@index([year, month])
}

model TasteMatch {
  id      String @id @default(cuid())
  user1Id String
  user2Id String

  // Compatibility scores
  overallScore        Float // 0-100 compatibility percentage
  genreOverlap        Float // How much genres overlap
  artistOverlap       Float // Shared artist preferences
  ratingAlignment     Float // How similarly they rate albums
  signatureSimilarity Float? // Polarity 1.2 signature similarity
  networkResonance    Json?  // How well networks align (Record<string, number>)
  networkContrast     Json?  // Complementary network differences (Record<string, number>)
  matchStrength       Float? // Overall match strength 0-1

  // Shared elements for display
  sharedGenres  String[]
  sharedArtists String[]
  sharedAlbums  String[] // Album IDs both rated highly

  // Relationship descriptor
  matchType String // "taste_twin" | "complementary" | "explorer_guide" | "genre_buddy"

  // Connection status
  status          String?   @default("potential") // "potential" | "connected" | "dismissed"
  connectedAt     DateTime?
  lastInteraction DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tasteId1 TasteID @relation("tasteUser1", fields: [user1Id], references: [userId], onDelete: Cascade)
  tasteId2 TasteID @relation("tasteUser2", fields: [user2Id], references: [userId], onDelete: Cascade)

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
  @@index([overallScore])
  @@index([matchType])
  @@index([status])
}

// ============================================
// MONETIZATION - WAX ECONOMY
// ============================================

model WaxTransaction {
  id          String   @id @default(cuid())
  userId      String
  amount      Int // positive = earn, negative = spend
  type        TxType
  description String
  metadata    Json? // Additional context (e.g., reviewId, itemId)
  createdAt   DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([type])
  @@index([createdAt])
  @@index([userId, createdAt])
}

model Purchase {
  id              String         @id @default(cuid())
  userId          String
  stripeSessionId String?        @unique
  stripePaymentId String?
  type            PurchaseType
  amount          Int // Amount in cents
  waxAmount       Int? // For wax pack purchases
  productId       String? // Reference to product/tier
  status          PurchaseStatus @default(PENDING)
  metadata        Json?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([stripeSessionId])
  @@index([status])
  @@index([createdAt])
}

// ============================================
// SHOP SYSTEM
// ============================================

model ShopItem {
  id          String   @id @default(cuid())
  type        ItemType
  name        String
  description String?
  waxPrice    Int
  imageUrl    String?

  // Scarcity mechanics
  isLimited Boolean   @default(false)
  stock     Int? // null = unlimited
  soldCount Int       @default(0)
  expiresAt DateTime? // For time-limited items

  // Tier restrictions
  minTier SubTier @default(FREE) // Minimum tier required to purchase

  // Display
  isActive  Boolean @default(true)
  sortOrder Int     @default(0)
  metadata  Json? // { rarity, color, animation, etc. }

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userItems UserItem[]

  @@index([type])
  @@index([isActive])
  @@index([isLimited])
  @@index([expiresAt])
}

model UserItem {
  id          String   @id @default(cuid())
  userId      String
  itemId      String
  equipped    Boolean  @default(false)
  purchaseNum Int? // For limited items: "You own #47 of 500"
  createdAt   DateTime @default(now())

  user User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  item ShopItem @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([userId, itemId])
  @@index([userId])
  @@index([itemId])
  @@index([equipped])
}

// Track first reviews on albums for bonus wax
model FirstAlbumReview {
  id        String   @id @default(cuid())
  userId    String
  albumId   String
  createdAt DateTime @default(now())

  @@unique([userId, albumId])
  @@index([userId])
  @@index([albumId])
}

// Flash sales for FOMO
model FlashSale {
  id          String   @id @default(cuid())
  name        String
  discountPct Int // 10-50 percent off
  startsAt    DateTime
  endsAt      DateTime
  isActive    Boolean  @default(true)
  appliesTo   String[] // Product IDs or "all_wax_packs"

  createdAt DateTime @default(now())

  @@index([isActive])
  @@index([startsAt])
  @@index([endsAt])
}

// ============================================
// FIRST SPIN BADGE SYSTEM
// ============================================

enum SpinBadgeType {
  GOLD // First 10 reviewers
  SILVER // First 50 reviewers
  BRONZE // First 100 reviewers
}

model FirstSpinBadge {
  id         String        @id @default(cuid())
  userId     String
  albumId    String
  badgeType  SpinBadgeType
  position   Int // What position they were (1-100)
  waxAwarded Int // How much wax they received
  createdAt  DateTime      @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  album Album @relation(fields: [albumId], references: [id], onDelete: Cascade)

  @@unique([userId, albumId]) // One badge per user per album
  @@index([userId])
  @@index([albumId])
  @@index([badgeType])
  @@index([createdAt])
}

// ============================================
// COLLEGE RADIO STATIONS
// ============================================

model Station {
  id         String  @id @default(cuid())
  name       String  @unique // e.g. "WRVU Nashville"
  slug       String  @unique // e.g. "wrvu"
  university String? // e.g. "Vanderbilt University"
  conference String? // e.g. "SEC", "Big Ten"
  logoUrl    String?
  websiteUrl String?
  email      String? // Contact email for the station

  // Founding Station Program
  isFoundingStation Boolean @default(false) // First 50 stations get permanent premium

  // Aggregate stats
  totalReviews    Int @default(0)
  tastemakeScore  Int @default(0) // Sum of all member tastemaker scores
  goldSpinCount   Int @default(0)
  silverSpinCount Int @default(0)
  bronzeSpinCount Int @default(0)

  // Subscription
  isPremium    Boolean   @default(false)
  premiumUntil DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  members StationMember[]

  @@index([conference])
  @@index([tastemakeScore])
  @@index([isFoundingStation])
}

model StationMember {
  id        String   @id @default(cuid())
  stationId String
  userId    String
  role      String   @default("dj") // dj, manager, admin
  joinedAt  DateTime @default(now())

  station Station @relation(fields: [stationId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([stationId, userId])
  @@index([stationId])
  @@index([userId])
}

// ============================================
// SOCIAL MESSAGING - Zero to One Features
// ============================================

// Direct Messages - Taste-Gated (60%+ match required)
model Conversation {
  id              String    @id @default(cuid())
  user1Id         String // Sorted: always lower ID first
  user2Id         String
  tasteMatchScore Float // Cached at creation (must be >= 60)
  lastMessageAt   DateTime?
  createdAt       DateTime  @default(now())

  user1    User      @relation("convUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2    User      @relation("convUser2", fields: [user2Id], references: [id], onDelete: Cascade)
  messages Message[]

  @@unique([user1Id, user2Id])
  @@index([user1Id, lastMessageAt])
  @@index([user2Id, lastMessageAt])
}

model Message {
  id             String   @id @default(cuid())
  conversationId String
  senderId       String
  content        String   @db.Text
  albumContextId String? // Optional: "Let's talk about this album"
  isRead         Boolean  @default(false)
  createdAt      DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation("messageSender", fields: [senderId], references: [id], onDelete: Cascade)
  albumContext Album?       @relation("messageAlbumContext", fields: [albumContextId], references: [id])

  @@index([conversationId, createdAt])
  @@index([senderId])
  @@index([isRead])
}

// Album Rooms - Must have reviewed the album to participate
model AlbumRoom {
  id           String    @id @default(cuid())
  albumId      String    @unique
  messageCount Int       @default(0)
  lastActivity DateTime?
  createdAt    DateTime  @default(now())

  album    Album         @relation(fields: [albumId], references: [id], onDelete: Cascade)
  messages RoomMessage[]

  @@index([lastActivity])
}

model RoomMessage {
  id                 String   @id @default(cuid())
  roomId             String
  userId             String
  content            String   @db.Text
  userFirstSpinBadge String? // "gold" | "silver" | "bronze" | null (denormalized)
  userReviewPosition Int? // Denormalized for display
  createdAt          DateTime @default(now())

  room AlbumRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user User      @relation("roomMessageSender", fields: [userId], references: [id], onDelete: Cascade)

  @@index([roomId, createdAt])
  @@index([userId])
}

// Taste Circles - Archetype-based communities
model TasteCircle {
  id          String   @id @default(cuid())
  archetype   String   @unique // Matches TasteID.primaryArchetype slug
  displayName String // "Hip-Hop Heads"
  description String?  @db.Text
  memberCount Int      @default(0) // Cached count of users with this archetype
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  messages CircleMessage[]

  @@index([archetype])
  @@index([memberCount])
}

model CircleMessage {
  id             String   @id @default(cuid())
  circleId       String
  userId         String
  content        String   @db.Text
  userArchetype  String // Primary archetype at time of posting
  userTasteScore Int // Tastemaker score at time of posting
  createdAt      DateTime @default(now())

  circle TasteCircle @relation(fields: [circleId], references: [id], onDelete: Cascade)
  user   User        @relation("circleMessageSender", fields: [userId], references: [id], onDelete: Cascade)

  @@index([circleId, createdAt])
  @@index([userId])
}
