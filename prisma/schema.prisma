// Waxfeed Database Schema
// Social music review platform - "Letterboxd for music"

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER ROLES
// ============================================

enum UserRole {
  USER      // Regular user
  PREMIUM   // Premium subscriber - all features unlocked
  ADMIN     // Admin - all features + admin panel access
}

// ============================================
// USER & AUTHENTICATION
// ============================================

model User {
  id                    String    @id @default(cuid())
  email                 String    @unique
  password              String?   // Hashed password for credentials auth
  emailVerified         DateTime?
  username              String?   @unique
  name                  String?
  image                 String?
  bio                   String?   @db.VarChar(150)
  socialLinks           Json?     // { instagram, twitter, spotify, etc. }
  role                  UserRole  @default(USER)
  waxScore              Int       @default(0)
  premiumWaxScore       Int       @default(0)
  isPremium             Boolean   @default(false)
  premiumExpiresAt      DateTime?
  isVerified            Boolean   @default(false)
  verifiedAt            DateTime?
  usernameChangesUsed   Int       @default(0)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Streak tracking
  currentStreak         Int       @default(0)
  longestStreak         Int       @default(0)
  lastReviewDate        DateTime?

  // Auth relations (NextAuth)
  accounts              Account[]
  sessions              Session[]

  // Content relations
  reviews               Review[]
  replies               Reply[]
  lists                 List[]
  reviewDrafts          ReviewDraft[]

  // Social relations (friends only)
  friendRequestsSent    FriendRequest[] @relation("sender")
  friendRequestsReceived FriendRequest[] @relation("receiver")
  friendshipsAsUser1    Friendship[]   @relation("user1")
  friendshipsAsUser2    Friendship[]   @relation("user2")

  // Engagement relations
  reviewLikes           ReviewLike[]
  reviewReactions       ReviewReaction[]
  replyLikes            ReplyLike[]
  listLikes             ListLike[]
  listComments          ListComment[]
  waxGiven              WaxAward[]     @relation("giver")

  // Moderation relations
  blocksInitiated       Block[]        @relation("blocker")
  blocksReceived        Block[]        @relation("blocked")
  reportsSubmitted      Report[]       @relation("reporter")
  notifications         Notification[]

  // Notification settings
  notificationSettings  NotificationSettings?

  // Pinned content
  pinnedReviewId        String?
  pinnedListId          String?

  // Hot takes relations
  hotTakes              HotTake[]
  hotTakeVotes          HotTakeVote[]
  hotTakeArguments      HotTakeArgument[]

  // TasteID relation
  tasteId               TasteID?

  @@index([username])
  @@index([email])
  @@index([createdAt])
}

// NextAuth required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================
// ALBUMS & ARTISTS
// ============================================

model Album {
  id              String    @id @default(cuid())
  spotifyId       String    @unique
  title           String
  artistName      String
  artistSpotifyId String?
  releaseDate     DateTime
  releaseDatePrecision String @default("day") // day, month, year
  coverArtUrl     String?
  coverArtUrlSmall String?  // 64px
  coverArtUrlMedium String? // 300px
  coverArtUrlLarge String?  // 640px
  genres          String[]  // From Spotify
  albumType       String    @default("album") // album, single, ep, compilation
  totalTracks     Int       @default(0)
  spotifyUrl      String?
  appleMusicUrl   String?
  tidalUrl        String?
  youtubeMusicUrl String?

  // Billboard tracking
  billboardRank   Int?      // Current Billboard 200 position (null if not on chart)
  billboardDate   DateTime? // Date of the chart position

  // Cached stats
  averageRating   Float?
  totalReviews    Int       @default(0)
  totalRatings    Int       @default(0)
  ratingDistribution Json?  // { "0": 5, "1": 3, ... "10": 20 }

  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  lastSyncedAt    DateTime  @default(now())

  // Relations
  reviews         Review[]
  listItems       ListItem[]
  tracks          Track[]
  userTags        AlbumTag[]
  hotTakes        HotTake[]

  @@index([spotifyId])
  @@index([artistName])
  @@index([releaseDate])
  @@index([averageRating])
  @@index([totalReviews])
  @@index([billboardRank])
}

model Track {
  id              String  @id @default(cuid())
  spotifyId       String  @unique
  albumId         String
  name            String
  trackNumber     Int
  discNumber      Int     @default(1)
  durationMs      Int
  previewUrl      String? // 30-second Spotify preview
  spotifyUrl      String?

  album           Album   @relation(fields: [albumId], references: [id], onDelete: Cascade)
  lyrics          Lyrics?

  @@index([albumId])
}

model Artist {
  id              String   @id @default(cuid())
  spotifyId       String   @unique
  name            String
  imageUrl        String?
  genres          String[]
  popularity      Int?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  lastSyncedAt    DateTime @default(now())

  @@index([spotifyId])
  @@index([name])
}

model AlbumTag {
  id        String   @id @default(cuid())
  albumId   String
  userId    String
  tag       String   @db.VarChar(50)
  createdAt DateTime @default(now())

  album     Album    @relation(fields: [albumId], references: [id], onDelete: Cascade)

  @@unique([albumId, userId, tag])
  @@index([albumId])
  @@index([tag])
}

// ============================================
// REVIEWS & RATINGS
// ============================================

model Review {
  id            String    @id @default(cuid())
  userId        String
  albumId       String
  rating        Float     // 0-10, supports decimals like 7.5
  text          String?   @db.Text // 5000 char limit enforced in app
  isEdited      Boolean   @default(false)
  editHistory   Json?     // [{ text, rating, editedAt }]
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Stats
  likeCount     Int       @default(0)
  waxCount      Int       @default(0)
  premiumWaxCount Int     @default(0)
  replyCount    Int       @default(0)

  // Reaction counts
  fireCount         Int   @default(0)
  insightfulCount   Int   @default(0)
  funnyCount        Int   @default(0)
  controversialCount Int  @default(0)

  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  album         Album     @relation(fields: [albumId], references: [id], onDelete: Cascade)

  replies       Reply[]
  likes         ReviewLike[]
  reactions     ReviewReaction[]
  waxAwards     WaxAward[]

  @@unique([userId, albumId])
  @@index([userId])
  @@index([albumId])
  @@index([createdAt])
  @@index([likeCount])
  @@index([rating])
}

model ReviewDraft {
  id        String   @id @default(cuid())
  userId    String
  albumId   String
  rating    Float?
  text      String?  @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, albumId])
  @@index([userId])
}

model Reply {
  id            String   @id @default(cuid())
  reviewId      String
  userId        String
  text          String   @db.Text // 2000 char limit enforced in app
  isEdited      Boolean  @default(false)
  editHistory   Json?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  likeCount     Int      @default(0)

  review        Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  likes         ReplyLike[]

  @@index([reviewId])
  @@index([userId])
  @@index([createdAt])
  @@index([likeCount])
}

model ReviewLike {
  id        String   @id @default(cuid())
  reviewId  String
  userId    String
  createdAt DateTime @default(now())

  review    Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([reviewId, userId])
  @@index([reviewId])
  @@index([userId])
}

model ReviewReaction {
  id        String   @id @default(cuid())
  reviewId  String
  userId    String
  type      String   // "fire", "insightful", "funny", "controversial"
  createdAt DateTime @default(now())

  review    Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([reviewId, userId, type])
  @@index([reviewId])
  @@index([userId])
  @@index([type])
}

model ReplyLike {
  id        String   @id @default(cuid())
  replyId   String
  userId    String
  createdAt DateTime @default(now())

  reply     Reply    @relation(fields: [replyId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([replyId, userId])
  @@index([replyId])
  @@index([userId])
}

// ============================================
// LISTS
// ============================================

model List {
  id              String    @id @default(cuid())
  userId          String
  title           String    @db.VarChar(200)
  description     String?   @db.Text
  isRanked        Boolean   @default(true)
  isPublic        Boolean   @default(true)
  allowRemix      Boolean   @default(true)
  remixedFromId   String?   // If this list was remixed from another
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  publishedAt     DateTime?

  likeCount       Int       @default(0)
  commentCount    Int       @default(0)

  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  remixedFrom     List?     @relation("remixes", fields: [remixedFromId], references: [id])
  remixes         List[]    @relation("remixes")

  items           ListItem[]
  likes           ListLike[]
  comments        ListComment[]
  reorderSuggestions ListReorderSuggestion[]

  @@index([userId])
  @@index([createdAt])
  @@index([likeCount])
  @@index([isPublic])
  @@index([userId, createdAt]) // For user's lists sorted by date
}

model ListItem {
  id        String  @id @default(cuid())
  listId    String
  albumId   String
  position  Int
  notes     String? @db.Text

  list      List    @relation(fields: [listId], references: [id], onDelete: Cascade)
  album     Album   @relation(fields: [albumId], references: [id], onDelete: Cascade)

  @@unique([listId, albumId])
  @@index([listId])
  @@index([position])
}

model ListLike {
  id        String   @id @default(cuid())
  listId    String
  userId    String
  createdAt DateTime @default(now())

  list      List     @relation(fields: [listId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([listId, userId])
  @@index([listId])
  @@index([userId])
}

model ListComment {
  id        String   @id @default(cuid())
  listId    String
  userId    String
  text      String   @db.Text
  isEdited  Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  list      List     @relation(fields: [listId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([listId])
  @@index([userId])
}

model ListReorderSuggestion {
  id              String   @id @default(cuid())
  listId          String
  suggesterId     String
  suggestedOrder  Json     // Array of album IDs in suggested order
  rationale       String   @db.Text
  status          String   @default("pending") // pending, accepted, rejected
  createdAt       DateTime @default(now())

  list            List     @relation(fields: [listId], references: [id], onDelete: Cascade)

  @@index([listId])
  @@index([status])
}

// ============================================
// SOCIAL (Friends Only)
// ============================================

model FriendRequest {
  id          String   @id @default(cuid())
  senderId    String
  receiverId  String
  status      String   @default("pending") // pending, accepted, rejected
  createdAt   DateTime @default(now())
  respondedAt DateTime?

  sender      User     @relation("sender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver    User     @relation("receiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@index([senderId])
  @@index([receiverId])
  @@index([status])
}

model Friendship {
  id        String   @id @default(cuid())
  user1Id   String
  user2Id   String
  createdAt DateTime @default(now())

  user1     User     @relation("user1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2     User     @relation("user2", fields: [user2Id], references: [id], onDelete: Cascade)

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
}

model Block {
  id        String   @id @default(cuid())
  blockerId String
  blockedId String
  createdAt DateTime @default(now())

  blocker   User     @relation("blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked   User     @relation("blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
}

// ============================================
// WAX SYSTEM
// ============================================

model WaxAward {
  id        String   @id @default(cuid())
  reviewId  String
  giverId   String
  waxType   String   @default("standard") // standard, premium
  createdAt DateTime @default(now())

  review    Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  giver     User     @relation("giver", fields: [giverId], references: [id], onDelete: Cascade)

  @@unique([reviewId, giverId])
  @@index([reviewId])
  @@index([giverId])
  @@index([waxType])
}

// ============================================
// NOTIFICATIONS
// ============================================

model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String   // reply, like, friend_request, friend_accept, review_trending, friend_review
  content   Json     // { actorId, actorName, reviewId, albumTitle, etc. }
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
  @@index([userId, isRead, createdAt]) // Compound index for common query pattern
}

model NotificationSettings {
  id                String  @id @default(cuid())
  userId            String  @unique
  replies           Boolean @default(true)
  likes             Boolean @default(true)
  friendRequests    Boolean @default(true)
  friendReviews     Boolean @default(true)
  reviewTrending    Boolean @default(true)

  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// ============================================
// MODERATION
// ============================================

model Report {
  id          String   @id @default(cuid())
  reporterId  String
  contentType String   // review, reply, list, user
  contentId   String
  reason      String   // spam, offensive, harassment, other
  details     String?  @db.Text
  status      String   @default("pending") // pending, reviewed, resolved, dismissed
  createdAt   DateTime @default(now())
  resolvedAt  DateTime?
  resolvedBy  String?

  reporter    User     @relation("reporter", fields: [reporterId], references: [id], onDelete: Cascade)

  @@index([reporterId])
  @@index([contentType])
  @@index([status])
}

// ============================================
// ANALYTICS (for Year-End features)
// ============================================

model UserYearlyStats {
  id              String @id @default(cuid())
  userId          String
  year            Int
  totalReviews    Int    @default(0)
  totalLists      Int    @default(0)
  averageRating   Float?
  topGenres       Json?  // [{ genre, count }]
  topArtists      Json?  // [{ artistName, count }]
  ratingDistribution Json? // { "0": 1, ... "10": 5 }
  monthlyActivity Json?  // { "1": 5, "2": 10, ... }

  @@unique([userId, year])
  @@index([userId])
  @@index([year])
}

// ============================================
// SPOTIFY API CACHE
// ============================================

model SpotifyCache {
  id        String   @id @default(cuid())
  key       String   @unique // e.g., "album:spotifyId" or "search:query"
  data      Json
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([key])
  @@index([expiresAt])
}

// ============================================
// LYRICS CACHE
// ============================================

model Lyrics {
  id          String   @id @default(cuid())
  trackId     String   @unique // Our internal track ID
  geniusId    String?  // Genius song ID for linking
  geniusUrl   String?  // Link to Genius page
  lyrics      String?  @db.Text // The actual lyrics text
  syncedLyrics Json?   // Synced/timed lyrics if available
  source      String   @default("genius") // genius, musixmatch, etc
  notFound    Boolean  @default(false) // True if we searched and found nothing
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  track       Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)

  @@index([trackId])
  @@index([geniusId])
}

// ============================================
// HOT TAKES (Community Debates)
// ============================================

model HotTake {
  id        String   @id @default(cuid())
  albumId   String
  authorId  String
  stance    String   // OVERRATED, UNDERRATED, MASTERPIECE, TRASH, AHEAD_OF_TIME, DATED
  content   String   @db.VarChar(280)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Cached counts for performance
  voteCount Int @default(0)

  album     Album        @relation(fields: [albumId], references: [id], onDelete: Cascade)
  author    User         @relation(fields: [authorId], references: [id], onDelete: Cascade)
  votes     HotTakeVote[]
  arguments HotTakeArgument[]

  @@unique([albumId, authorId]) // One hot take per album per user
  @@index([albumId])
  @@index([authorId])
  @@index([createdAt])
  @@index([voteCount])
  @@index([stance])
}

model HotTakeVote {
  id        String   @id @default(cuid())
  hotTakeId String
  userId    String
  vote      String   // agree, disagree
  createdAt DateTime @default(now())

  hotTake   HotTake  @relation(fields: [hotTakeId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([hotTakeId, userId])
  @@index([hotTakeId])
  @@index([userId])
  @@index([vote])
}

model HotTakeArgument {
  id        String   @id @default(cuid())
  hotTakeId String
  authorId  String
  side      String   // agree, disagree
  content   String   @db.VarChar(500)
  likes     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  hotTake   HotTake  @relation(fields: [hotTakeId], references: [id], onDelete: Cascade)
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([hotTakeId])
  @@index([authorId])
  @@index([side])
  @@index([likes])
}

// ============================================
// TASTEID - Music Taste Fingerprint System
// ============================================

model TasteID {
  id                  String   @id @default(cuid())
  userId              String   @unique

  // Core taste vectors
  genreVector         Json     // { "hip-hop": 0.85, "jazz": 0.72, ... } - 0-1 affinities
  artistDNA           Json     // Top 20 defining artists with weights
  decadePreferences   Json     // { "1990s": 0.6, "2000s": 0.4, ... }

  // Archetype classification
  primaryArchetype    String   // "Hip-Hop Head", "Jazz Explorer", etc.
  secondaryArchetype  String?  // Optional secondary classification
  archetypeConfidence Float    @default(0) // 0-1 confidence in classification

  // Behavioral metrics
  adventurenessScore  Float    @default(0.5) // 0-1, how diverse their taste is
  ratingSkew          String   @default("balanced") // "harsh" | "lenient" | "balanced"
  averageRating       Float    @default(5)
  ratingStdDev        Float    @default(0) // Standard deviation of ratings

  // Engagement signals
  reviewDepth         String   @default("rater") // "rater" | "writer" | "essayist"
  reviewCount         Int      @default(0)
  avgReviewLength     Int      @default(0) // Average word count

  // Computed display data
  topGenres           String[] // Top 5 genres for display
  topArtists          String[] // Top 10 artists for display
  signatureAlbums     String[] // Album IDs that define their taste

  // Polarity Points - Bayesian edge strength from CCX
  polarityScore       Float    @default(0) // Overall taste distinctiveness

  // Polarity 1.2 - Cognitive modeling for music
  listeningSignature  Json?    // { "discovery": 0.35, "comfort": 0.22, ... } - Music network activation baseline
  signaturePatterns   String[] // Detected patterns: ["Discoveryâ†”Comfort Oscillation", "Deep Dive Sprints"]
  memorableMoments    Json?    // Episodic memory: notable rating moments (first 10, first 0, etc.)
  futureSelvesMusic   Json?    // Prospective musical trajectories and skill trees
  consolidationHistory Json?   // How taste has consolidated over time
  polarityScore2      Float?   // Enhanced Polarity 1.2 score with cognitive factors

  // Timestamps
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  lastComputedAt      DateTime @default(now())

  // Relations
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  snapshots           TasteIDSnapshot[]
  matchesAsUser1      TasteMatch[] @relation("tasteUser1")
  matchesAsUser2      TasteMatch[] @relation("tasteUser2")

  @@index([primaryArchetype])
  @@index([adventurenessScore])
  @@index([polarityScore])
}

model TasteIDSnapshot {
  id              String   @id @default(cuid())
  tasteIdId       String

  // Snapshot of taste state
  genreVector     Json
  artistDNA       Json
  primaryArchetype String
  adventurenessScore Float
  reviewCount     Int

  // Polarity 1.2 - Listening signature snapshot for drift tracking
  listeningSignature Json?
  polarityScore2     Float?

  // When this snapshot was taken
  month           Int      // 1-12
  year            Int
  createdAt       DateTime @default(now())

  tasteId         TasteID  @relation(fields: [tasteIdId], references: [id], onDelete: Cascade)

  @@unique([tasteIdId, year, month])
  @@index([tasteIdId])
  @@index([year, month])
}

model TasteMatch {
  id              String   @id @default(cuid())
  user1Id         String
  user2Id         String

  // Compatibility scores
  overallScore    Float    // 0-100 compatibility percentage
  genreOverlap    Float    // How much genres overlap
  artistOverlap   Float    // Shared artist preferences
  ratingAlignment Float    // How similarly they rate albums

  // Polarity 1.2 - Network-based matching
  signatureSimilarity Float?    // Listening signature cosine similarity (0-1)
  networkResonance    Json?     // { network: strength } - which networks align
  networkContrast     Json?     // { network: diff } - complementary differences
  matchStrength       Float?    // Combined algorithm confidence (0-1)

  // Shared elements for display
  sharedGenres    String[]
  sharedArtists   String[]
  sharedAlbums    String[] // Album IDs both rated highly

  // Relationship descriptor - enhanced with Polarity types
  matchType       String   // "taste_twin" | "opposite_attracts" | "network_resonance" | "explorer_guide" | "complementary" | "genre_buddy"

  // Connection status
  status          String   @default("potential") // "potential" | "connected" | "dismissed"
  connectedAt     DateTime?
  lastInteraction DateTime?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  tasteId1        TasteID  @relation("tasteUser1", fields: [user1Id], references: [userId], onDelete: Cascade)
  tasteId2        TasteID  @relation("tasteUser2", fields: [user2Id], references: [userId], onDelete: Cascade)

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
  @@index([overallScore])
  @@index([matchType])
  @@index([status])
  @@index([matchStrength])
}

// ============================================
// TASTE CHALLENGES - Gamified taste exploration
// ============================================

model TasteChallenge {
  id              String   @id @default(cuid())
  creatorId       String
  partnerId       String

  // Challenge details
  challengeType   String   // "discover_together" | "rate_same_album" | "genre_swap" | "decade_dive"
  targetAlbumId   String?  // For rate_same_album challenges
  targetGenre     String?  // For genre_swap challenges
  targetDecade    String?  // For decade_dive challenges
  title           String?  // Custom challenge title

  // Progress tracking
  status          String   @default("pending") // "pending" | "active" | "completed" | "expired"
  creatorProgress Json?    // { albumsRated: [], score: number }
  partnerProgress Json?    // { albumsRated: [], score: number }

  // Results
  winnerId        String?
  completedAt     DateTime?
  expiresAt       DateTime

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([creatorId])
  @@index([partnerId])
  @@index([status])
  @@index([expiresAt])
}

// ============================================
// SHARED LISTENING - Real-time music sessions
// ============================================

model SharedListeningSession {
  id              String   @id @default(cuid())
  hostId          String
  guestId         String?  // null if open invite

  // Session details
  title           String?
  currentAlbumId  String?  // Album currently being listened to
  currentTrackIndex Int    @default(0)
  isPlaying       Boolean  @default(false)
  playbackPosition Int     @default(0) // in seconds

  // Session state
  status          String   @default("waiting") // "waiting" | "active" | "paused" | "ended"
  inviteCode      String   @unique // For sharing invite links

  // Chat within session
  messages        SharedListeningMessage[]

  // Timestamps
  startedAt       DateTime?
  endedAt         DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([hostId])
  @@index([guestId])
  @@index([status])
  @@index([inviteCode])
}

model SharedListeningMessage {
  id        String   @id @default(cuid())
  sessionId String
  userId    String
  content   String   @db.VarChar(500)
  type      String   @default("text") // "text" | "reaction" | "album_suggestion"
  metadata  Json?    // For album suggestions: { albumId, albumTitle, etc }

  createdAt DateTime @default(now())

  session   SharedListeningSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([userId])
  @@index([createdAt])
}

// ============================================
// DIRECT MESSAGES - Connection chat
// ============================================

model Conversation {
  id           String   @id @default(cuid())
  participant1Id String
  participant2Id String

  // Last message preview
  lastMessageAt   DateTime?
  lastMessageText String?  @db.VarChar(100)

  // Unread counts
  participant1Unread Int @default(0)
  participant2Unread Int @default(0)

  messages     DirectMessage[]

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([participant1Id, participant2Id])
  @@index([participant1Id])
  @@index([participant2Id])
  @@index([lastMessageAt])
}

model DirectMessage {
  id             String   @id @default(cuid())
  conversationId String
  senderId       String
  content        String   @db.Text
  type           String   @default("text") // "text" | "album_share" | "challenge_invite" | "session_invite"
  metadata       Json?    // For shared content: { albumId, challengeId, sessionId, etc }

  isRead         Boolean  @default(false)
  readAt         DateTime?

  createdAt      DateTime @default(now())

  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([senderId])
  @@index([createdAt])
  @@index([isRead])
}
