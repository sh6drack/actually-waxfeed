// Waxfeed Database Schema
// Social music review platform - "Letterboxd for music"

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER & AUTHENTICATION
// ============================================

model User {
  id                    String    @id @default(cuid())
  email                 String    @unique
  password              String?   // Hashed password for credentials auth
  emailVerified         DateTime?
  username              String?   @unique
  name                  String?
  image                 String?
  bio                   String?   @db.VarChar(150)
  socialLinks           Json?     // { instagram, twitter, spotify, etc. }
  waxScore              Int       @default(0)
  premiumWaxScore       Int       @default(0)
  isPremium             Boolean   @default(false)
  premiumExpiresAt      DateTime?
  isVerified            Boolean   @default(false)
  verifiedAt            DateTime?
  usernameChangesUsed   Int       @default(0)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Streak tracking
  currentStreak         Int       @default(0)
  longestStreak         Int       @default(0)
  lastReviewDate        DateTime?

  // Auth relations (NextAuth)
  accounts              Account[]
  sessions              Session[]

  // Content relations
  reviews               Review[]
  replies               Reply[]
  lists                 List[]
  reviewDrafts          ReviewDraft[]

  // Social relations (friends only)
  friendRequestsSent    FriendRequest[] @relation("sender")
  friendRequestsReceived FriendRequest[] @relation("receiver")
  friendshipsAsUser1    Friendship[]   @relation("user1")
  friendshipsAsUser2    Friendship[]   @relation("user2")

  // Engagement relations
  reviewLikes           ReviewLike[]
  reviewReactions       ReviewReaction[]
  replyLikes            ReplyLike[]
  listLikes             ListLike[]
  listComments          ListComment[]
  waxGiven              WaxAward[]     @relation("giver")

  // Moderation relations
  blocksInitiated       Block[]        @relation("blocker")
  blocksReceived        Block[]        @relation("blocked")
  reportsSubmitted      Report[]       @relation("reporter")
  notifications         Notification[]

  // Notification settings
  notificationSettings  NotificationSettings?

  // Pinned content
  pinnedReviewId        String?
  pinnedListId          String?

  @@index([username])
  @@index([email])
  @@index([createdAt])
}

// NextAuth required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================
// ALBUMS & ARTISTS
// ============================================

model Album {
  id              String    @id @default(cuid())
  spotifyId       String    @unique
  title           String
  artistName      String
  artistSpotifyId String?
  releaseDate     DateTime
  releaseDatePrecision String @default("day") // day, month, year
  coverArtUrl     String?
  coverArtUrlSmall String?  // 64px
  coverArtUrlMedium String? // 300px
  coverArtUrlLarge String?  // 640px
  genres          String[]  // From Spotify
  albumType       String    @default("album") // album, single, ep, compilation
  totalTracks     Int       @default(0)
  spotifyUrl      String?
  appleMusicUrl   String?
  tidalUrl        String?
  youtubeMusicUrl String?

  // Billboard tracking
  billboardRank   Int?      // Current Billboard 200 position (null if not on chart)
  billboardDate   DateTime? // Date of the chart position

  // Cached stats
  averageRating   Float?
  totalReviews    Int       @default(0)
  totalRatings    Int       @default(0)
  ratingDistribution Json?  // { "0": 5, "1": 3, ... "10": 20 }

  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  lastSyncedAt    DateTime  @default(now())

  // Relations
  reviews         Review[]
  listItems       ListItem[]
  tracks          Track[]
  userTags        AlbumTag[]

  @@index([spotifyId])
  @@index([artistName])
  @@index([releaseDate])
  @@index([averageRating])
  @@index([totalReviews])
  @@index([billboardRank])
}

model Track {
  id              String  @id @default(cuid())
  spotifyId       String  @unique
  albumId         String
  name            String
  trackNumber     Int
  discNumber      Int     @default(1)
  durationMs      Int
  previewUrl      String? // 30-second Spotify preview
  spotifyUrl      String?

  album           Album   @relation(fields: [albumId], references: [id], onDelete: Cascade)
  lyrics          Lyrics?

  @@index([albumId])
}

model Artist {
  id              String   @id @default(cuid())
  spotifyId       String   @unique
  name            String
  imageUrl        String?
  genres          String[]
  popularity      Int?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  lastSyncedAt    DateTime @default(now())

  @@index([spotifyId])
  @@index([name])
}

model AlbumTag {
  id        String   @id @default(cuid())
  albumId   String
  userId    String
  tag       String   @db.VarChar(50)
  createdAt DateTime @default(now())

  album     Album    @relation(fields: [albumId], references: [id], onDelete: Cascade)

  @@unique([albumId, userId, tag])
  @@index([albumId])
  @@index([tag])
}

// ============================================
// REVIEWS & RATINGS
// ============================================

model Review {
  id            String    @id @default(cuid())
  userId        String
  albumId       String
  rating        Float     // 0-10, supports decimals like 7.5
  text          String?   @db.Text // 5000 char limit enforced in app
  isEdited      Boolean   @default(false)
  editHistory   Json?     // [{ text, rating, editedAt }]
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Stats
  likeCount     Int       @default(0)
  waxCount      Int       @default(0)
  premiumWaxCount Int     @default(0)
  replyCount    Int       @default(0)

  // Reaction counts
  fireCount         Int   @default(0)
  insightfulCount   Int   @default(0)
  funnyCount        Int   @default(0)
  controversialCount Int  @default(0)

  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  album         Album     @relation(fields: [albumId], references: [id], onDelete: Cascade)

  replies       Reply[]
  likes         ReviewLike[]
  reactions     ReviewReaction[]
  waxAwards     WaxAward[]

  @@unique([userId, albumId])
  @@index([userId])
  @@index([albumId])
  @@index([createdAt])
  @@index([likeCount])
  @@index([rating])
}

model ReviewDraft {
  id        String   @id @default(cuid())
  userId    String
  albumId   String
  rating    Float?
  text      String?  @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, albumId])
  @@index([userId])
}

model Reply {
  id            String   @id @default(cuid())
  reviewId      String
  userId        String
  text          String   @db.Text // 2000 char limit enforced in app
  isEdited      Boolean  @default(false)
  editHistory   Json?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  likeCount     Int      @default(0)

  review        Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  likes         ReplyLike[]

  @@index([reviewId])
  @@index([userId])
  @@index([createdAt])
  @@index([likeCount])
}

model ReviewLike {
  id        String   @id @default(cuid())
  reviewId  String
  userId    String
  createdAt DateTime @default(now())

  review    Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([reviewId, userId])
  @@index([reviewId])
  @@index([userId])
}

model ReviewReaction {
  id        String   @id @default(cuid())
  reviewId  String
  userId    String
  type      String   // "fire", "insightful", "funny", "controversial"
  createdAt DateTime @default(now())

  review    Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([reviewId, userId, type])
  @@index([reviewId])
  @@index([userId])
  @@index([type])
}

model ReplyLike {
  id        String   @id @default(cuid())
  replyId   String
  userId    String
  createdAt DateTime @default(now())

  reply     Reply    @relation(fields: [replyId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([replyId, userId])
  @@index([replyId])
  @@index([userId])
}

// ============================================
// LISTS
// ============================================

model List {
  id              String    @id @default(cuid())
  userId          String
  title           String    @db.VarChar(200)
  description     String?   @db.Text
  isRanked        Boolean   @default(true)
  isPublic        Boolean   @default(true)
  allowRemix      Boolean   @default(true)
  remixedFromId   String?   // If this list was remixed from another
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  publishedAt     DateTime?

  likeCount       Int       @default(0)
  commentCount    Int       @default(0)

  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  remixedFrom     List?     @relation("remixes", fields: [remixedFromId], references: [id])
  remixes         List[]    @relation("remixes")

  items           ListItem[]
  likes           ListLike[]
  comments        ListComment[]
  reorderSuggestions ListReorderSuggestion[]

  @@index([userId])
  @@index([createdAt])
  @@index([likeCount])
  @@index([isPublic])
}

model ListItem {
  id        String  @id @default(cuid())
  listId    String
  albumId   String
  position  Int
  notes     String? @db.Text

  list      List    @relation(fields: [listId], references: [id], onDelete: Cascade)
  album     Album   @relation(fields: [albumId], references: [id], onDelete: Cascade)

  @@unique([listId, albumId])
  @@index([listId])
  @@index([position])
}

model ListLike {
  id        String   @id @default(cuid())
  listId    String
  userId    String
  createdAt DateTime @default(now())

  list      List     @relation(fields: [listId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([listId, userId])
  @@index([listId])
  @@index([userId])
}

model ListComment {
  id        String   @id @default(cuid())
  listId    String
  userId    String
  text      String   @db.Text
  isEdited  Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  list      List     @relation(fields: [listId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([listId])
  @@index([userId])
}

model ListReorderSuggestion {
  id              String   @id @default(cuid())
  listId          String
  suggesterId     String
  suggestedOrder  Json     // Array of album IDs in suggested order
  rationale       String   @db.Text
  status          String   @default("pending") // pending, accepted, rejected
  createdAt       DateTime @default(now())

  list            List     @relation(fields: [listId], references: [id], onDelete: Cascade)

  @@index([listId])
  @@index([status])
}

// ============================================
// SOCIAL (Friends Only)
// ============================================

model FriendRequest {
  id          String   @id @default(cuid())
  senderId    String
  receiverId  String
  status      String   @default("pending") // pending, accepted, rejected
  createdAt   DateTime @default(now())
  respondedAt DateTime?

  sender      User     @relation("sender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver    User     @relation("receiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@index([senderId])
  @@index([receiverId])
  @@index([status])
}

model Friendship {
  id        String   @id @default(cuid())
  user1Id   String
  user2Id   String
  createdAt DateTime @default(now())

  user1     User     @relation("user1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2     User     @relation("user2", fields: [user2Id], references: [id], onDelete: Cascade)

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
}

model Block {
  id        String   @id @default(cuid())
  blockerId String
  blockedId String
  createdAt DateTime @default(now())

  blocker   User     @relation("blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked   User     @relation("blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
}

// ============================================
// WAX SYSTEM
// ============================================

model WaxAward {
  id        String   @id @default(cuid())
  reviewId  String
  giverId   String
  waxType   String   @default("standard") // standard, premium
  createdAt DateTime @default(now())

  review    Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  giver     User     @relation("giver", fields: [giverId], references: [id], onDelete: Cascade)

  @@unique([reviewId, giverId])
  @@index([reviewId])
  @@index([giverId])
  @@index([waxType])
}

// ============================================
// NOTIFICATIONS
// ============================================

model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String   // reply, like, friend_request, friend_accept, review_trending, friend_review
  content   Json     // { actorId, actorName, reviewId, albumTitle, etc. }
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
}

model NotificationSettings {
  id                String  @id @default(cuid())
  userId            String  @unique
  replies           Boolean @default(true)
  likes             Boolean @default(true)
  friendRequests    Boolean @default(true)
  friendReviews     Boolean @default(true)
  reviewTrending    Boolean @default(true)

  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// ============================================
// MODERATION
// ============================================

model Report {
  id          String   @id @default(cuid())
  reporterId  String
  contentType String   // review, reply, list, user
  contentId   String
  reason      String   // spam, offensive, harassment, other
  details     String?  @db.Text
  status      String   @default("pending") // pending, reviewed, resolved, dismissed
  createdAt   DateTime @default(now())
  resolvedAt  DateTime?
  resolvedBy  String?

  reporter    User     @relation("reporter", fields: [reporterId], references: [id], onDelete: Cascade)

  @@index([reporterId])
  @@index([contentType])
  @@index([status])
}

// ============================================
// ANALYTICS (for Year-End features)
// ============================================

model UserYearlyStats {
  id              String @id @default(cuid())
  userId          String
  year            Int
  totalReviews    Int    @default(0)
  totalLists      Int    @default(0)
  averageRating   Float?
  topGenres       Json?  // [{ genre, count }]
  topArtists      Json?  // [{ artistName, count }]
  ratingDistribution Json? // { "0": 1, ... "10": 5 }
  monthlyActivity Json?  // { "1": 5, "2": 10, ... }

  @@unique([userId, year])
  @@index([userId])
  @@index([year])
}

// ============================================
// SPOTIFY API CACHE
// ============================================

model SpotifyCache {
  id        String   @id @default(cuid())
  key       String   @unique // e.g., "album:spotifyId" or "search:query"
  data      Json
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([key])
  @@index([expiresAt])
}

// ============================================
// LYRICS CACHE
// ============================================

model Lyrics {
  id          String   @id @default(cuid())
  trackId     String   @unique // Our internal track ID
  geniusId    String?  // Genius song ID for linking
  geniusUrl   String?  // Link to Genius page
  lyrics      String?  @db.Text // The actual lyrics text
  syncedLyrics Json?   // Synced/timed lyrics if available
  source      String   @default("genius") // genius, musixmatch, etc
  notFound    Boolean  @default(false) // True if we searched and found nothing
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  track       Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)

  @@index([trackId])
  @@index([geniusId])
}
